"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@formkit+auto-animate@0.9.0";
exports.ids = ["vendor-chunks/@formkit+auto-animate@0.9.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@formkit+auto-animate@0.9.0/node_modules/@formkit/auto-animate/index.mjs":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@formkit+auto-animate@0.9.0/node_modules/@formkit/auto-animate/index.mjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoAnimate: () => (/* binding */ autoAnimate),\n/* harmony export */   \"default\": () => (/* binding */ autoAnimate),\n/* harmony export */   getTransitionSizes: () => (/* binding */ getTransitionSizes),\n/* harmony export */   vAutoAnimate: () => (/* binding */ vAutoAnimate)\n/* harmony export */ });\n/**\n * A set of all the parents currently being observe. This is the only non weak\n * registry.\n */\nconst parents = new Set();\n/**\n * Element coordinates that is constantly kept up to date.\n */\nconst coords = new WeakMap();\n/**\n * Siblings of elements that have been removed from the dom.\n */\nconst siblings = new WeakMap();\n/**\n * Animations that are currently running.\n */\nconst animations = new WeakMap();\n/**\n * A map of existing intersection observers used to track element movements.\n */\nconst intersections = new WeakMap();\n/**\n * A map of existing mutation observers used to track element movements.\n */\nconst mutationObservers = new WeakMap();\n/**\n * Intervals for automatically checking the position of elements occasionally.\n */\nconst intervals = new WeakMap();\n/**\n * The configuration options for each group of elements.\n */\nconst options = new WeakMap();\n/**\n * Debounce counters by id, used to debounce calls to update positions.\n */\nconst debounces = new WeakMap();\n/**\n * All parents that are currently enabled are tracked here.\n */\nconst enabled = new WeakSet();\n/**\n * The document used to calculate transitions.\n */\nlet root;\n/**\n * The root’s XY scroll positions.\n */\nlet scrollX = 0;\nlet scrollY = 0;\n/**\n * Used to sign an element as the target.\n */\nconst TGT = \"__aa_tgt\";\n/**\n * Used to sign an element as being part of a removal.\n */\nconst DEL = \"__aa_del\";\n/**\n * Used to sign an element as being \"new\". When an element is removed from the\n * dom, but may cycle back in we can sign it with new to ensure the next time\n * it is recognized we consider it new.\n */\nconst NEW = \"__aa_new\";\n/**\n * Callback for handling all mutations.\n * @param mutations - A mutation list\n */\nconst handleMutations = (mutations) => {\n    const elements = getElements(mutations);\n    // If elements is \"false\" that means this mutation that should be ignored.\n    if (elements) {\n        elements.forEach((el) => animate(el));\n    }\n};\n/**\n *\n * @param entries - Elements that have been resized.\n */\nconst handleResizes = (entries) => {\n    entries.forEach((entry) => {\n        if (entry.target === root)\n            updateAllPos();\n        if (coords.has(entry.target))\n            updatePos(entry.target);\n    });\n};\n/**\n * Determine if an element is fully outside of the current viewport.\n * @param el - Element to test\n */\nfunction isOffscreen(el) {\n    const rect = el.getBoundingClientRect();\n    const vw = (root === null || root === void 0 ? void 0 : root.clientWidth) || 0;\n    const vh = (root === null || root === void 0 ? void 0 : root.clientHeight) || 0;\n    return rect.bottom < 0 || rect.top > vh || rect.right < 0 || rect.left > vw;\n}\n/**\n * Observe this elements position.\n * @param el - The element to observe the position of.\n */\nfunction observePosition(el) {\n    const oldObserver = intersections.get(el);\n    oldObserver === null || oldObserver === void 0 ? void 0 : oldObserver.disconnect();\n    let rect = coords.get(el);\n    let invocations = 0;\n    const buffer = 5;\n    if (!rect) {\n        rect = getCoords(el);\n        coords.set(el, rect);\n    }\n    const { offsetWidth, offsetHeight } = root;\n    const rootMargins = [\n        rect.top - buffer,\n        offsetWidth - (rect.left + buffer + rect.width),\n        offsetHeight - (rect.top + buffer + rect.height),\n        rect.left - buffer,\n    ];\n    const rootMargin = rootMargins\n        .map((px) => `${ -1 * Math.floor(px)}px`)\n        .join(\" \");\n    const observer = new IntersectionObserver(() => {\n        ++invocations > 1 && updatePos(el);\n    }, {\n        root,\n        threshold: 1,\n        rootMargin,\n    });\n    observer.observe(el);\n    intersections.set(el, observer);\n}\n/**\n * Update the exact position of a given element.\n * @param el - An element to update the position of.\n * @param debounce - Whether or not to debounce the update. After an animation is finished, it should update as soon as possible to prevent flickering on quick toggles.\n */\nfunction updatePos(el, debounce = true) {\n    clearTimeout(debounces.get(el));\n    const optionsOrPlugin = getOptions(el);\n    const delay = debounce\n        ? isPlugin(optionsOrPlugin)\n            ? 500\n            : optionsOrPlugin.duration\n        : 0;\n    debounces.set(el, setTimeout(async () => {\n        const currentAnimation = animations.get(el);\n        try {\n            await (currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.finished);\n            coords.set(el, getCoords(el));\n            observePosition(el);\n        }\n        catch {\n            // ignore errors as the `.finished` promise is rejected when animations were cancelled\n        }\n    }, delay));\n}\n/**\n * Updates all positions that are currently being tracked.\n */\nfunction updateAllPos() {\n    clearTimeout(debounces.get(root));\n    debounces.set(root, setTimeout(() => {\n        parents.forEach((parent) => forEach(parent, (el) => lowPriority(() => updatePos(el))));\n    }, 100));\n}\n/**\n * Its possible for a quick scroll or other fast events to get past the\n * intersection observer, so occasionally we need want \"cold-poll\" for the\n * latests and greatest position. We try to do this in the most non-disruptive\n * fashion possible. First we only do this ever couple seconds, staggard by a\n * random offset.\n * @param el - Element\n */\nfunction poll(el) {\n    setTimeout(() => {\n        intervals.set(el, setInterval(() => lowPriority(updatePos.bind(null, el)), 2000));\n    }, Math.round(2000 * Math.random()));\n}\n/**\n * Perform some operation that is non critical at some point.\n * @param callback\n */\nfunction lowPriority(callback) {\n    if (typeof requestIdleCallback === \"function\") {\n        requestIdleCallback(() => callback());\n    }\n    else {\n        requestAnimationFrame(() => callback());\n    }\n}\n/**\n * A resize observer, responsible for recalculating elements on resize.\n */\nlet resize;\n/**\n * Ensure the browser is supported.\n */\nconst supportedBrowser = typeof window !== \"undefined\" && \"ResizeObserver\" in window;\n/**\n * If this is in a browser, initialize our Web APIs\n */\nif (supportedBrowser) {\n    root = document.documentElement;\n    new MutationObserver(handleMutations);\n    resize = new ResizeObserver(handleResizes);\n    window.addEventListener(\"scroll\", () => {\n        scrollY = window.scrollY;\n        scrollX = window.scrollX;\n    });\n    resize.observe(root);\n}\n/**\n * Retrieves all the elements that may have been affected by the last mutation\n * including ones that have been removed and are no longer in the DOM.\n * @param mutations - A mutation list.\n * @returns\n */\nfunction getElements(mutations) {\n    const observedNodes = mutations.reduce((nodes, mutation) => {\n        return [\n            ...nodes,\n            ...Array.from(mutation.addedNodes),\n            ...Array.from(mutation.removedNodes),\n        ];\n    }, []);\n    // Short circuit if _only_ comment nodes are observed\n    const onlyCommentNodesObserved = observedNodes.every((node) => node.nodeName === \"#comment\");\n    if (onlyCommentNodesObserved)\n        return false;\n    return mutations.reduce((elements, mutation) => {\n        // Short circuit if we find a purposefully deleted node.\n        if (elements === false)\n            return false;\n        if (mutation.target instanceof Element) {\n            target(mutation.target);\n            if (!elements.has(mutation.target)) {\n                elements.add(mutation.target);\n                for (let i = 0; i < mutation.target.children.length; i++) {\n                    const child = mutation.target.children.item(i);\n                    if (!child)\n                        continue;\n                    if (DEL in child) {\n                        return false;\n                    }\n                    target(mutation.target, child);\n                    elements.add(child);\n                }\n            }\n            if (mutation.removedNodes.length) {\n                for (let i = 0; i < mutation.removedNodes.length; i++) {\n                    const child = mutation.removedNodes[i];\n                    if (DEL in child) {\n                        return false;\n                    }\n                    if (child instanceof Element) {\n                        elements.add(child);\n                        target(mutation.target, child);\n                        siblings.set(child, [\n                            mutation.previousSibling,\n                            mutation.nextSibling,\n                        ]);\n                    }\n                }\n            }\n        }\n        return elements;\n    }, new Set());\n}\n/**\n * Assign the target to an element.\n * @param el - The root element\n * @param child\n */\nfunction target(el, child) {\n    if (!child && !(TGT in el))\n        Object.defineProperty(el, TGT, { value: el });\n    else if (child && !(TGT in child))\n        Object.defineProperty(child, TGT, { value: el });\n}\n/**\n * Determines what kind of change took place on the given element and then\n * performs the proper animation based on that.\n * @param el - The specific element to animate.\n */\nfunction animate(el) {\n    var _a, _b;\n    const isMounted = el.isConnected;\n    const preExisting = coords.has(el);\n    if (isMounted && siblings.has(el))\n        siblings.delete(el);\n    if (((_a = animations.get(el)) === null || _a === void 0 ? void 0 : _a.playState) !== \"finished\") {\n        (_b = animations.get(el)) === null || _b === void 0 ? void 0 : _b.cancel();\n    }\n    if (NEW in el) {\n        add(el);\n    }\n    else if (preExisting && isMounted) {\n        remain(el);\n    }\n    else if (preExisting && !isMounted) {\n        remove(el);\n    }\n    else {\n        add(el);\n    }\n}\n/**\n * Removes all non-digits from a string and casts to a number.\n * @param str - A string containing a pixel value.\n * @returns\n */\nfunction raw(str) {\n    return Number(str.replace(/[^0-9.\\-]/g, \"\"));\n}\n/**\n * Get the scroll offset of elements\n * @param el - Element\n * @returns\n */\nfunction getScrollOffset(el) {\n    let p = el.parentElement;\n    while (p) {\n        if (p.scrollLeft || p.scrollTop) {\n            return { x: p.scrollLeft, y: p.scrollTop };\n        }\n        p = p.parentElement;\n    }\n    return { x: 0, y: 0 };\n}\n/**\n * Get the coordinates of elements adjusted for scroll position.\n * @param el - Element\n * @returns\n */\nfunction getCoords(el) {\n    const rect = el.getBoundingClientRect();\n    const { x, y } = getScrollOffset(el);\n    return {\n        top: rect.top + y,\n        left: rect.left + x,\n        width: rect.width,\n        height: rect.height,\n    };\n}\n/**\n * Returns the width/height that the element should be transitioned between.\n * This takes into account box-sizing.\n * @param el - Element being animated\n * @param oldCoords - Old set of Coordinates coordinates\n * @param newCoords - New set of Coordinates coordinates\n * @returns\n */\nfunction getTransitionSizes(el, oldCoords, newCoords) {\n    let widthFrom = oldCoords.width;\n    let heightFrom = oldCoords.height;\n    let widthTo = newCoords.width;\n    let heightTo = newCoords.height;\n    const styles = getComputedStyle(el);\n    const sizing = styles.getPropertyValue(\"box-sizing\");\n    if (sizing === \"content-box\") {\n        const paddingY = raw(styles.paddingTop) +\n            raw(styles.paddingBottom) +\n            raw(styles.borderTopWidth) +\n            raw(styles.borderBottomWidth);\n        const paddingX = raw(styles.paddingLeft) +\n            raw(styles.paddingRight) +\n            raw(styles.borderRightWidth) +\n            raw(styles.borderLeftWidth);\n        widthFrom -= paddingX;\n        widthTo -= paddingX;\n        heightFrom -= paddingY;\n        heightTo -= paddingY;\n    }\n    return [widthFrom, widthTo, heightFrom, heightTo].map(Math.round);\n}\n/**\n * Retrieves animation options for the current element.\n * @param el - Element to retrieve options for.\n * @returns\n */\nfunction getOptions(el) {\n    return TGT in el && options.has(el[TGT])\n        ? options.get(el[TGT])\n        : { duration: 250, easing: \"ease-in-out\" };\n}\n/**\n * Returns the target of a given animation (generally the parent).\n * @param el - An element to check for a target\n * @returns\n */\nfunction getTarget(el) {\n    if (TGT in el)\n        return el[TGT];\n    return undefined;\n}\n/**\n * Checks if animations are enabled or disabled for a given element.\n * @param el - Any element\n * @returns\n */\nfunction isEnabled(el) {\n    const target = getTarget(el);\n    return target ? enabled.has(target) : false;\n}\n/**\n * Iterate over the children of a given parent.\n * @param parent - A parent element\n * @param callback - A callback\n */\nfunction forEach(parent, ...callbacks) {\n    callbacks.forEach((callback) => callback(parent, options.has(parent)));\n    for (let i = 0; i < parent.children.length; i++) {\n        const child = parent.children.item(i);\n        if (child) {\n            callbacks.forEach((callback) => callback(child, options.has(child)));\n        }\n    }\n}\n/**\n * Always return tuple to provide consistent interface\n */\nfunction getPluginTuple(pluginReturn) {\n    if (Array.isArray(pluginReturn))\n        return pluginReturn;\n    return [pluginReturn];\n}\n/**\n * Determine if config is plugin\n */\nfunction isPlugin(config) {\n    return typeof config === \"function\";\n}\n/**\n * The element in question is remaining in the DOM.\n * @param el - Element to flip\n * @returns\n */\nfunction remain(el) {\n    const oldCoords = coords.get(el);\n    const newCoords = getCoords(el);\n    if (!isEnabled(el))\n        return coords.set(el, newCoords);\n    if (isOffscreen(el)) {\n        // When element is offscreen, skip FLIP to avoid broken transforms\n        coords.set(el, newCoords);\n        observePosition(el);\n        return;\n    }\n    let animation;\n    if (!oldCoords)\n        return;\n    const pluginOrOptions = getOptions(el);\n    if (typeof pluginOrOptions !== \"function\") {\n        let deltaLeft = oldCoords.left - newCoords.left;\n        let deltaTop = oldCoords.top - newCoords.top;\n        const deltaRight = oldCoords.left + oldCoords.width - (newCoords.left + newCoords.width);\n        const deltaBottom = oldCoords.top + oldCoords.height - (newCoords.top + newCoords.height);\n        // element is probably anchored and doesn't need to be offset\n        if (deltaBottom == 0)\n            deltaTop = 0;\n        if (deltaRight == 0)\n            deltaLeft = 0;\n        const [widthFrom, widthTo, heightFrom, heightTo] = getTransitionSizes(el, oldCoords, newCoords);\n        const start = {\n            transform: `translate(${deltaLeft}px, ${deltaTop}px)`,\n        };\n        const end = {\n            transform: `translate(0, 0)`,\n        };\n        if (widthFrom !== widthTo) {\n            start.width = `${widthFrom}px`;\n            end.width = `${widthTo}px`;\n        }\n        if (heightFrom !== heightTo) {\n            start.height = `${heightFrom}px`;\n            end.height = `${heightTo}px`;\n        }\n        animation = el.animate([start, end], {\n            duration: pluginOrOptions.duration,\n            easing: pluginOrOptions.easing,\n        });\n    }\n    else {\n        const [keyframes] = getPluginTuple(pluginOrOptions(el, \"remain\", oldCoords, newCoords));\n        animation = new Animation(keyframes);\n        animation.play();\n    }\n    animations.set(el, animation);\n    coords.set(el, newCoords);\n    animation.addEventListener(\"finish\", updatePos.bind(null, el, false), {\n        once: true,\n    });\n}\n/**\n * Adds the element with a transition.\n * @param el - Animates the element being added.\n */\nfunction add(el) {\n    if (NEW in el)\n        delete el[NEW];\n    const newCoords = getCoords(el);\n    coords.set(el, newCoords);\n    const pluginOrOptions = getOptions(el);\n    if (!isEnabled(el))\n        return;\n    if (isOffscreen(el)) {\n        // Skip entry animation if element is not visible in viewport\n        observePosition(el);\n        return;\n    }\n    let animation;\n    if (typeof pluginOrOptions !== \"function\") {\n        animation = el.animate([\n            { transform: \"scale(.98)\", opacity: 0 },\n            { transform: \"scale(0.98)\", opacity: 0, offset: 0.5 },\n            { transform: \"scale(1)\", opacity: 1 },\n        ], {\n            duration: pluginOrOptions.duration * 1.5,\n            easing: \"ease-in\",\n        });\n    }\n    else {\n        const [keyframes] = getPluginTuple(pluginOrOptions(el, \"add\", newCoords));\n        animation = new Animation(keyframes);\n        animation.play();\n    }\n    animations.set(el, animation);\n    animation.addEventListener(\"finish\", updatePos.bind(null, el, false), {\n        once: true,\n    });\n}\n/**\n * Clean up after removing an element from the dom.\n * @param el - Element being removed\n * @param styles - Optional styles that should be removed from the element.\n */\nfunction cleanUp(el, styles) {\n    var _a;\n    el.remove();\n    coords.delete(el);\n    siblings.delete(el);\n    animations.delete(el);\n    (_a = intersections.get(el)) === null || _a === void 0 ? void 0 : _a.disconnect();\n    setTimeout(() => {\n        if (DEL in el)\n            delete el[DEL];\n        Object.defineProperty(el, NEW, { value: true, configurable: true });\n        if (styles && el instanceof HTMLElement) {\n            for (const style in styles) {\n                el.style[style] = \"\";\n            }\n        }\n    }, 0);\n}\n/**\n * Animates the removal of an element.\n * @param el - Element to remove\n */\nfunction remove(el) {\n    var _a;\n    if (!siblings.has(el) || !coords.has(el))\n        return;\n    const [prev, next] = siblings.get(el);\n    Object.defineProperty(el, DEL, { value: true, configurable: true });\n    const finalX = window.scrollX;\n    const finalY = window.scrollY;\n    if (next &&\n        next.parentNode &&\n        next.parentNode instanceof Element) {\n        next.parentNode.insertBefore(el, next);\n    }\n    else if (prev && prev.parentNode) {\n        prev.parentNode.appendChild(el);\n    }\n    else {\n        (_a = getTarget(el)) === null || _a === void 0 ? void 0 : _a.appendChild(el);\n    }\n    if (!isEnabled(el))\n        return cleanUp(el);\n    const [top, left, width, height] = deletePosition(el);\n    const optionsOrPlugin = getOptions(el);\n    const oldCoords = coords.get(el);\n    if (finalX !== scrollX || finalY !== scrollY) {\n        adjustScroll(el, finalX, finalY, optionsOrPlugin);\n    }\n    let animation;\n    let styleReset = {\n        position: \"absolute\",\n        top: `${top}px`,\n        left: `${left}px`,\n        width: `${width}px`,\n        height: `${height}px`,\n        margin: \"0\",\n        pointerEvents: \"none\",\n        transformOrigin: \"center\",\n        zIndex: \"100\",\n    };\n    if (!isPlugin(optionsOrPlugin)) {\n        Object.assign(el.style, styleReset);\n        animation = el.animate([\n            {\n                transform: \"scale(1)\",\n                opacity: 1,\n            },\n            {\n                transform: \"scale(.98)\",\n                opacity: 0,\n            },\n        ], {\n            duration: optionsOrPlugin.duration,\n            easing: \"ease-out\",\n        });\n    }\n    else {\n        const [keyframes, options] = getPluginTuple(optionsOrPlugin(el, \"remove\", oldCoords));\n        if ((options === null || options === void 0 ? void 0 : options.styleReset) !== false) {\n            styleReset =\n                (options === null || options === void 0 ? void 0 : options.styleReset) ||\n                    styleReset;\n            Object.assign(el.style, styleReset);\n        }\n        animation = new Animation(keyframes);\n        animation.play();\n    }\n    animations.set(el, animation);\n    animation.addEventListener(\"finish\", () => cleanUp(el, styleReset), {\n        once: true,\n    });\n}\n/**\n * If the element being removed is at the very bottom of the page, and the\n * the page was scrolled into a space being \"made available\" by the element\n * that was removed, the page scroll will have jumped up some amount. We need\n * to offset the jump by the amount that the page was \"automatically\" scrolled\n * up. We can do this by comparing the scroll position before and after the\n * element was removed, and then offsetting by that amount.\n *\n * @param el - The element being deleted\n * @param finalX - The final X scroll position\n * @param finalY - The final Y scroll position\n * @param optionsOrPlugin - The options or plugin\n * @returns\n */\nfunction adjustScroll(el, finalX, finalY, optionsOrPlugin) {\n    const scrollDeltaX = scrollX - finalX;\n    const scrollDeltaY = scrollY - finalY;\n    const scrollBefore = document.documentElement.style.scrollBehavior;\n    const scrollBehavior = getComputedStyle(root).scrollBehavior;\n    if (scrollBehavior === \"smooth\") {\n        document.documentElement.style.scrollBehavior = \"auto\";\n    }\n    window.scrollTo(window.scrollX + scrollDeltaX, window.scrollY + scrollDeltaY);\n    if (!el.parentElement)\n        return;\n    const parent = el.parentElement;\n    let lastHeight = parent.clientHeight;\n    let lastWidth = parent.clientWidth;\n    const startScroll = performance.now();\n    // Here we use a manual scroll animation to keep the element using the same\n    // easing and timing as the parent’s scroll animation.\n    function smoothScroll() {\n        requestAnimationFrame(() => {\n            if (!isPlugin(optionsOrPlugin)) {\n                const deltaY = lastHeight - parent.clientHeight;\n                const deltaX = lastWidth - parent.clientWidth;\n                if (startScroll + optionsOrPlugin.duration >\n                    performance.now()) {\n                    window.scrollTo({\n                        left: window.scrollX - deltaX,\n                        top: window.scrollY - deltaY,\n                    });\n                    lastHeight = parent.clientHeight;\n                    lastWidth = parent.clientWidth;\n                    smoothScroll();\n                }\n                else {\n                    document.documentElement.style.scrollBehavior = scrollBefore;\n                }\n            }\n        });\n    }\n    smoothScroll();\n}\n/**\n * Determines the position of the element being removed.\n * @param el - The element being deleted\n * @returns\n */\nfunction deletePosition(el) {\n    var _a;\n    const oldCoords = coords.get(el);\n    const [width, , height] = getTransitionSizes(el, oldCoords, getCoords(el));\n    let offsetParent = el.parentElement;\n    while (offsetParent &&\n        (getComputedStyle(offsetParent).position === \"static\" ||\n            offsetParent instanceof HTMLBodyElement)) {\n        offsetParent = offsetParent.parentElement;\n    }\n    if (!offsetParent)\n        offsetParent = document.body;\n    const parentStyles = getComputedStyle(offsetParent);\n    const parentCoords = !animations.has(el) || ((_a = animations.get(el)) === null || _a === void 0 ? void 0 : _a.playState) === \"finished\"\n        ? getCoords(offsetParent)\n        : coords.get(offsetParent);\n    const top = Math.round(oldCoords.top - parentCoords.top) -\n        raw(parentStyles.borderTopWidth);\n    const left = Math.round(oldCoords.left - parentCoords.left) -\n        raw(parentStyles.borderLeftWidth);\n    return [top, left, width, height];\n}\n/**\n * A function that automatically adds animation effects to itself and its\n * immediate children. Specifically it adds effects for adding, moving, and\n * removing DOM elements.\n * @param el - A parent element to add animations to.\n * @param options - An optional object of options.\n */\nfunction autoAnimate(el, config = {}) {\n    if (supportedBrowser && resize) {\n        const mediaQuery = window.matchMedia(\"(prefers-reduced-motion: reduce)\");\n        const isDisabledDueToReduceMotion = mediaQuery.matches &&\n            !isPlugin(config) &&\n            !config.disrespectUserMotionPreference;\n        if (!isDisabledDueToReduceMotion) {\n            enabled.add(el);\n            if (getComputedStyle(el).position === \"static\") {\n                Object.assign(el.style, { position: \"relative\" });\n            }\n            forEach(el, updatePos, poll, (element) => resize === null || resize === void 0 ? void 0 : resize.observe(element));\n            if (isPlugin(config)) {\n                options.set(el, config);\n            }\n            else {\n                options.set(el, {\n                    duration: 250,\n                    easing: \"ease-in-out\",\n                    ...config,\n                });\n            }\n            const mo = new MutationObserver(handleMutations);\n            mo.observe(el, { childList: true });\n            mutationObservers.set(el, mo);\n            parents.add(el);\n        }\n    }\n    const controller = Object.freeze({\n        parent: el,\n        enable: () => {\n            enabled.add(el);\n        },\n        disable: () => {\n            enabled.delete(el);\n            // Cancel any in-flight animations and pending timers for immediate effect\n            forEach(el, (node) => {\n                const a = animations.get(node);\n                try {\n                    a === null || a === void 0 ? void 0 : a.cancel();\n                }\n                catch { }\n                animations.delete(node);\n                const d = debounces.get(node);\n                if (d)\n                    clearTimeout(d);\n                debounces.delete(node);\n                const i = intervals.get(node);\n                if (i)\n                    clearInterval(i);\n                intervals.delete(node);\n            });\n        },\n        isEnabled: () => enabled.has(el),\n        destroy: () => {\n            enabled.delete(el);\n            parents.delete(el);\n            options.delete(el);\n            const mo = mutationObservers.get(el);\n            mo === null || mo === void 0 ? void 0 : mo.disconnect();\n            mutationObservers.delete(el);\n            forEach(el, (node) => {\n                // unobserve resize\n                resize === null || resize === void 0 ? void 0 : resize.unobserve(node);\n                // cancel animations\n                const a = animations.get(node);\n                try {\n                    a === null || a === void 0 ? void 0 : a.cancel();\n                }\n                catch { }\n                animations.delete(node);\n                // disconnect observers\n                const io = intersections.get(node);\n                io === null || io === void 0 ? void 0 : io.disconnect();\n                intersections.delete(node);\n                // clear intervals and debounces\n                const i = intervals.get(node);\n                if (i)\n                    clearInterval(i);\n                intervals.delete(node);\n                const d = debounces.get(node);\n                if (d)\n                    clearTimeout(d);\n                debounces.delete(node);\n                // clear state\n                coords.delete(node);\n                siblings.delete(node);\n            });\n        },\n    });\n    return controller;\n}\n/**\n * The vue directive.\n */\nconst vAutoAnimate = {\n    mounted: (el, binding) => {\n        const ctl = autoAnimate(el, binding.value || {});\n        Object.defineProperty(el, \"__aa_ctl\", { value: ctl, configurable: true });\n    },\n    unmounted: (el) => {\n        var _a;\n        const ctl = el[\"__aa_ctl\"];\n        (_a = ctl === null || ctl === void 0 ? void 0 : ctl.destroy) === null || _a === void 0 ? void 0 : _a.call(ctl);\n        try {\n            delete el[\"__aa_ctl\"];\n        }\n        catch { }\n    },\n    getSSRProps: () => ({}),\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bmb3Jta2l0K2F1dG8tYW5pbWF0ZUAwLjkuMC9ub2RlX21vZHVsZXMvQGZvcm1raXQvYXV0by1hbmltYXRlL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUNBQXFDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsV0FBVztBQUNwRDtBQUNBLDRDQUE0QyxXQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVUsTUFBTSxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QywyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekMsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQ0FBcUM7QUFDbkQsY0FBYyxtREFBbUQ7QUFDakUsY0FBYyxtQ0FBbUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpQ0FBaUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQUk7QUFDcEIsaUJBQWlCLEtBQUs7QUFDdEIsa0JBQWtCLE1BQU07QUFDeEIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxnREFBZ0QsZ0NBQWdDO0FBQ2hGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQjtBQUMxQjs7QUFFaUYiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sYW5leWZyYWFzcy9EZXNrdG9wL0hJVkUvbm9kZV9tb2R1bGVzLy5wbnBtL0Bmb3Jta2l0K2F1dG8tYW5pbWF0ZUAwLjkuMC9ub2RlX21vZHVsZXMvQGZvcm1raXQvYXV0by1hbmltYXRlL2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgc2V0IG9mIGFsbCB0aGUgcGFyZW50cyBjdXJyZW50bHkgYmVpbmcgb2JzZXJ2ZS4gVGhpcyBpcyB0aGUgb25seSBub24gd2Vha1xuICogcmVnaXN0cnkuXG4gKi9cbmNvbnN0IHBhcmVudHMgPSBuZXcgU2V0KCk7XG4vKipcbiAqIEVsZW1lbnQgY29vcmRpbmF0ZXMgdGhhdCBpcyBjb25zdGFudGx5IGtlcHQgdXAgdG8gZGF0ZS5cbiAqL1xuY29uc3QgY29vcmRzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogU2libGluZ3Mgb2YgZWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBkb20uXG4gKi9cbmNvbnN0IHNpYmxpbmdzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQW5pbWF0aW9ucyB0aGF0IGFyZSBjdXJyZW50bHkgcnVubmluZy5cbiAqL1xuY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEEgbWFwIG9mIGV4aXN0aW5nIGludGVyc2VjdGlvbiBvYnNlcnZlcnMgdXNlZCB0byB0cmFjayBlbGVtZW50IG1vdmVtZW50cy5cbiAqL1xuY29uc3QgaW50ZXJzZWN0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEEgbWFwIG9mIGV4aXN0aW5nIG11dGF0aW9uIG9ic2VydmVycyB1c2VkIHRvIHRyYWNrIGVsZW1lbnQgbW92ZW1lbnRzLlxuICovXG5jb25zdCBtdXRhdGlvbk9ic2VydmVycyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEludGVydmFscyBmb3IgYXV0b21hdGljYWxseSBjaGVja2luZyB0aGUgcG9zaXRpb24gb2YgZWxlbWVudHMgb2NjYXNpb25hbGx5LlxuICovXG5jb25zdCBpbnRlcnZhbHMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBlYWNoIGdyb3VwIG9mIGVsZW1lbnRzLlxuICovXG5jb25zdCBvcHRpb25zID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogRGVib3VuY2UgY291bnRlcnMgYnkgaWQsIHVzZWQgdG8gZGVib3VuY2UgY2FsbHMgdG8gdXBkYXRlIHBvc2l0aW9ucy5cbiAqL1xuY29uc3QgZGVib3VuY2VzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQWxsIHBhcmVudHMgdGhhdCBhcmUgY3VycmVudGx5IGVuYWJsZWQgYXJlIHRyYWNrZWQgaGVyZS5cbiAqL1xuY29uc3QgZW5hYmxlZCA9IG5ldyBXZWFrU2V0KCk7XG4vKipcbiAqIFRoZSBkb2N1bWVudCB1c2VkIHRvIGNhbGN1bGF0ZSB0cmFuc2l0aW9ucy5cbiAqL1xubGV0IHJvb3Q7XG4vKipcbiAqIFRoZSByb2904oCZcyBYWSBzY3JvbGwgcG9zaXRpb25zLlxuICovXG5sZXQgc2Nyb2xsWCA9IDA7XG5sZXQgc2Nyb2xsWSA9IDA7XG4vKipcbiAqIFVzZWQgdG8gc2lnbiBhbiBlbGVtZW50IGFzIHRoZSB0YXJnZXQuXG4gKi9cbmNvbnN0IFRHVCA9IFwiX19hYV90Z3RcIjtcbi8qKlxuICogVXNlZCB0byBzaWduIGFuIGVsZW1lbnQgYXMgYmVpbmcgcGFydCBvZiBhIHJlbW92YWwuXG4gKi9cbmNvbnN0IERFTCA9IFwiX19hYV9kZWxcIjtcbi8qKlxuICogVXNlZCB0byBzaWduIGFuIGVsZW1lbnQgYXMgYmVpbmcgXCJuZXdcIi4gV2hlbiBhbiBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSB0aGVcbiAqIGRvbSwgYnV0IG1heSBjeWNsZSBiYWNrIGluIHdlIGNhbiBzaWduIGl0IHdpdGggbmV3IHRvIGVuc3VyZSB0aGUgbmV4dCB0aW1lXG4gKiBpdCBpcyByZWNvZ25pemVkIHdlIGNvbnNpZGVyIGl0IG5ldy5cbiAqL1xuY29uc3QgTkVXID0gXCJfX2FhX25ld1wiO1xuLyoqXG4gKiBDYWxsYmFjayBmb3IgaGFuZGxpbmcgYWxsIG11dGF0aW9ucy5cbiAqIEBwYXJhbSBtdXRhdGlvbnMgLSBBIG11dGF0aW9uIGxpc3RcbiAqL1xuY29uc3QgaGFuZGxlTXV0YXRpb25zID0gKG11dGF0aW9ucykgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gZ2V0RWxlbWVudHMobXV0YXRpb25zKTtcbiAgICAvLyBJZiBlbGVtZW50cyBpcyBcImZhbHNlXCIgdGhhdCBtZWFucyB0aGlzIG11dGF0aW9uIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiBhbmltYXRlKGVsKSk7XG4gICAgfVxufTtcbi8qKlxuICpcbiAqIEBwYXJhbSBlbnRyaWVzIC0gRWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gcmVzaXplZC5cbiAqL1xuY29uc3QgaGFuZGxlUmVzaXplcyA9IChlbnRyaWVzKSA9PiB7XG4gICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICBpZiAoZW50cnkudGFyZ2V0ID09PSByb290KVxuICAgICAgICAgICAgdXBkYXRlQWxsUG9zKCk7XG4gICAgICAgIGlmIChjb29yZHMuaGFzKGVudHJ5LnRhcmdldCkpXG4gICAgICAgICAgICB1cGRhdGVQb3MoZW50cnkudGFyZ2V0KTtcbiAgICB9KTtcbn07XG4vKipcbiAqIERldGVybWluZSBpZiBhbiBlbGVtZW50IGlzIGZ1bGx5IG91dHNpZGUgb2YgdGhlIGN1cnJlbnQgdmlld3BvcnQuXG4gKiBAcGFyYW0gZWwgLSBFbGVtZW50IHRvIHRlc3RcbiAqL1xuZnVuY3Rpb24gaXNPZmZzY3JlZW4oZWwpIHtcbiAgICBjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgdncgPSAocm9vdCA9PT0gbnVsbCB8fCByb290ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb290LmNsaWVudFdpZHRoKSB8fCAwO1xuICAgIGNvbnN0IHZoID0gKHJvb3QgPT09IG51bGwgfHwgcm9vdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm9vdC5jbGllbnRIZWlnaHQpIHx8IDA7XG4gICAgcmV0dXJuIHJlY3QuYm90dG9tIDwgMCB8fCByZWN0LnRvcCA+IHZoIHx8IHJlY3QucmlnaHQgPCAwIHx8IHJlY3QubGVmdCA+IHZ3O1xufVxuLyoqXG4gKiBPYnNlcnZlIHRoaXMgZWxlbWVudHMgcG9zaXRpb24uXG4gKiBAcGFyYW0gZWwgLSBUaGUgZWxlbWVudCB0byBvYnNlcnZlIHRoZSBwb3NpdGlvbiBvZi5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZVBvc2l0aW9uKGVsKSB7XG4gICAgY29uc3Qgb2xkT2JzZXJ2ZXIgPSBpbnRlcnNlY3Rpb25zLmdldChlbCk7XG4gICAgb2xkT2JzZXJ2ZXIgPT09IG51bGwgfHwgb2xkT2JzZXJ2ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZE9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBsZXQgcmVjdCA9IGNvb3Jkcy5nZXQoZWwpO1xuICAgIGxldCBpbnZvY2F0aW9ucyA9IDA7XG4gICAgY29uc3QgYnVmZmVyID0gNTtcbiAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgcmVjdCA9IGdldENvb3JkcyhlbCk7XG4gICAgICAgIGNvb3Jkcy5zZXQoZWwsIHJlY3QpO1xuICAgIH1cbiAgICBjb25zdCB7IG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQgfSA9IHJvb3Q7XG4gICAgY29uc3Qgcm9vdE1hcmdpbnMgPSBbXG4gICAgICAgIHJlY3QudG9wIC0gYnVmZmVyLFxuICAgICAgICBvZmZzZXRXaWR0aCAtIChyZWN0LmxlZnQgKyBidWZmZXIgKyByZWN0LndpZHRoKSxcbiAgICAgICAgb2Zmc2V0SGVpZ2h0IC0gKHJlY3QudG9wICsgYnVmZmVyICsgcmVjdC5oZWlnaHQpLFxuICAgICAgICByZWN0LmxlZnQgLSBidWZmZXIsXG4gICAgXTtcbiAgICBjb25zdCByb290TWFyZ2luID0gcm9vdE1hcmdpbnNcbiAgICAgICAgLm1hcCgocHgpID0+IGAkeyAtMSAqIE1hdGguZmxvb3IocHgpfXB4YClcbiAgICAgICAgLmpvaW4oXCIgXCIpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgKytpbnZvY2F0aW9ucyA+IDEgJiYgdXBkYXRlUG9zKGVsKTtcbiAgICB9LCB7XG4gICAgICAgIHJvb3QsXG4gICAgICAgIHRocmVzaG9sZDogMSxcbiAgICAgICAgcm9vdE1hcmdpbixcbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsKTtcbiAgICBpbnRlcnNlY3Rpb25zLnNldChlbCwgb2JzZXJ2ZXIpO1xufVxuLyoqXG4gKiBVcGRhdGUgdGhlIGV4YWN0IHBvc2l0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudC5cbiAqIEBwYXJhbSBlbCAtIEFuIGVsZW1lbnQgdG8gdXBkYXRlIHRoZSBwb3NpdGlvbiBvZi5cbiAqIEBwYXJhbSBkZWJvdW5jZSAtIFdoZXRoZXIgb3Igbm90IHRvIGRlYm91bmNlIHRoZSB1cGRhdGUuIEFmdGVyIGFuIGFuaW1hdGlvbiBpcyBmaW5pc2hlZCwgaXQgc2hvdWxkIHVwZGF0ZSBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgZmxpY2tlcmluZyBvbiBxdWljayB0b2dnbGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGVQb3MoZWwsIGRlYm91bmNlID0gdHJ1ZSkge1xuICAgIGNsZWFyVGltZW91dChkZWJvdW5jZXMuZ2V0KGVsKSk7XG4gICAgY29uc3Qgb3B0aW9uc09yUGx1Z2luID0gZ2V0T3B0aW9ucyhlbCk7XG4gICAgY29uc3QgZGVsYXkgPSBkZWJvdW5jZVxuICAgICAgICA/IGlzUGx1Z2luKG9wdGlvbnNPclBsdWdpbilcbiAgICAgICAgICAgID8gNTAwXG4gICAgICAgICAgICA6IG9wdGlvbnNPclBsdWdpbi5kdXJhdGlvblxuICAgICAgICA6IDA7XG4gICAgZGVib3VuY2VzLnNldChlbCwgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBbmltYXRpb24gPSBhbmltYXRpb25zLmdldChlbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCAoY3VycmVudEFuaW1hdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50QW5pbWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50QW5pbWF0aW9uLmZpbmlzaGVkKTtcbiAgICAgICAgICAgIGNvb3Jkcy5zZXQoZWwsIGdldENvb3JkcyhlbCkpO1xuICAgICAgICAgICAgb2JzZXJ2ZVBvc2l0aW9uKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGFzIHRoZSBgLmZpbmlzaGVkYCBwcm9taXNlIGlzIHJlamVjdGVkIHdoZW4gYW5pbWF0aW9ucyB3ZXJlIGNhbmNlbGxlZFxuICAgICAgICB9XG4gICAgfSwgZGVsYXkpKTtcbn1cbi8qKlxuICogVXBkYXRlcyBhbGwgcG9zaXRpb25zIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyB0cmFja2VkLlxuICovXG5mdW5jdGlvbiB1cGRhdGVBbGxQb3MoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlcy5nZXQocm9vdCkpO1xuICAgIGRlYm91bmNlcy5zZXQocm9vdCwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHBhcmVudHMuZm9yRWFjaCgocGFyZW50KSA9PiBmb3JFYWNoKHBhcmVudCwgKGVsKSA9PiBsb3dQcmlvcml0eSgoKSA9PiB1cGRhdGVQb3MoZWwpKSkpO1xuICAgIH0sIDEwMCkpO1xufVxuLyoqXG4gKiBJdHMgcG9zc2libGUgZm9yIGEgcXVpY2sgc2Nyb2xsIG9yIG90aGVyIGZhc3QgZXZlbnRzIHRvIGdldCBwYXN0IHRoZVxuICogaW50ZXJzZWN0aW9uIG9ic2VydmVyLCBzbyBvY2Nhc2lvbmFsbHkgd2UgbmVlZCB3YW50IFwiY29sZC1wb2xsXCIgZm9yIHRoZVxuICogbGF0ZXN0cyBhbmQgZ3JlYXRlc3QgcG9zaXRpb24uIFdlIHRyeSB0byBkbyB0aGlzIGluIHRoZSBtb3N0IG5vbi1kaXNydXB0aXZlXG4gKiBmYXNoaW9uIHBvc3NpYmxlLiBGaXJzdCB3ZSBvbmx5IGRvIHRoaXMgZXZlciBjb3VwbGUgc2Vjb25kcywgc3RhZ2dhcmQgYnkgYVxuICogcmFuZG9tIG9mZnNldC5cbiAqIEBwYXJhbSBlbCAtIEVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gcG9sbChlbCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpbnRlcnZhbHMuc2V0KGVsLCBzZXRJbnRlcnZhbCgoKSA9PiBsb3dQcmlvcml0eSh1cGRhdGVQb3MuYmluZChudWxsLCBlbCkpLCAyMDAwKSk7XG4gICAgfSwgTWF0aC5yb3VuZCgyMDAwICogTWF0aC5yYW5kb20oKSkpO1xufVxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIHRoYXQgaXMgbm9uIGNyaXRpY2FsIGF0IHNvbWUgcG9pbnQuXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gbG93UHJpb3JpdHkoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IGNhbGxiYWNrKCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGNhbGxiYWNrKCkpO1xuICAgIH1cbn1cbi8qKlxuICogQSByZXNpemUgb2JzZXJ2ZXIsIHJlc3BvbnNpYmxlIGZvciByZWNhbGN1bGF0aW5nIGVsZW1lbnRzIG9uIHJlc2l6ZS5cbiAqL1xubGV0IHJlc2l6ZTtcbi8qKlxuICogRW5zdXJlIHRoZSBicm93c2VyIGlzIHN1cHBvcnRlZC5cbiAqL1xuY29uc3Qgc3VwcG9ydGVkQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJSZXNpemVPYnNlcnZlclwiIGluIHdpbmRvdztcbi8qKlxuICogSWYgdGhpcyBpcyBpbiBhIGJyb3dzZXIsIGluaXRpYWxpemUgb3VyIFdlYiBBUElzXG4gKi9cbmlmIChzdXBwb3J0ZWRCcm93c2VyKSB7XG4gICAgcm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVNdXRhdGlvbnMpO1xuICAgIHJlc2l6ZSA9IG5ldyBSZXNpemVPYnNlcnZlcihoYW5kbGVSZXNpemVzKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICAgIHNjcm9sbFkgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgc2Nyb2xsWCA9IHdpbmRvdy5zY3JvbGxYO1xuICAgIH0pO1xuICAgIHJlc2l6ZS5vYnNlcnZlKHJvb3QpO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgYWxsIHRoZSBlbGVtZW50cyB0aGF0IG1heSBoYXZlIGJlZW4gYWZmZWN0ZWQgYnkgdGhlIGxhc3QgbXV0YXRpb25cbiAqIGluY2x1ZGluZyBvbmVzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgYW5kIGFyZSBubyBsb25nZXIgaW4gdGhlIERPTS5cbiAqIEBwYXJhbSBtdXRhdGlvbnMgLSBBIG11dGF0aW9uIGxpc3QuXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRFbGVtZW50cyhtdXRhdGlvbnMpIHtcbiAgICBjb25zdCBvYnNlcnZlZE5vZGVzID0gbXV0YXRpb25zLnJlZHVjZSgobm9kZXMsIG11dGF0aW9uKSA9PiB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi5ub2RlcyxcbiAgICAgICAgICAgIC4uLkFycmF5LmZyb20obXV0YXRpb24uYWRkZWROb2RlcyksXG4gICAgICAgICAgICAuLi5BcnJheS5mcm9tKG11dGF0aW9uLnJlbW92ZWROb2RlcyksXG4gICAgICAgIF07XG4gICAgfSwgW10pO1xuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgX29ubHlfIGNvbW1lbnQgbm9kZXMgYXJlIG9ic2VydmVkXG4gICAgY29uc3Qgb25seUNvbW1lbnROb2Rlc09ic2VydmVkID0gb2JzZXJ2ZWROb2Rlcy5ldmVyeSgobm9kZSkgPT4gbm9kZS5ub2RlTmFtZSA9PT0gXCIjY29tbWVudFwiKTtcbiAgICBpZiAob25seUNvbW1lbnROb2Rlc09ic2VydmVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIG11dGF0aW9ucy5yZWR1Y2UoKGVsZW1lbnRzLCBtdXRhdGlvbikgPT4ge1xuICAgICAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGZpbmQgYSBwdXJwb3NlZnVsbHkgZGVsZXRlZCBub2RlLlxuICAgICAgICBpZiAoZWxlbWVudHMgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobXV0YXRpb24udGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgdGFyZ2V0KG11dGF0aW9uLnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnRzLmhhcyhtdXRhdGlvbi50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMuYWRkKG11dGF0aW9uLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi50YXJnZXQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBtdXRhdGlvbi50YXJnZXQuY2hpbGRyZW4uaXRlbShpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoREVMIGluIGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0KG11dGF0aW9uLnRhcmdldCwgY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChERUwgaW4gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0KG11dGF0aW9uLnRhcmdldCwgY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZ3Muc2V0KGNoaWxkLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24ucHJldmlvdXNTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uLm5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH0sIG5ldyBTZXQoKSk7XG59XG4vKipcbiAqIEFzc2lnbiB0aGUgdGFyZ2V0IHRvIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0gZWwgLSBUaGUgcm9vdCBlbGVtZW50XG4gKiBAcGFyYW0gY2hpbGRcbiAqL1xuZnVuY3Rpb24gdGFyZ2V0KGVsLCBjaGlsZCkge1xuICAgIGlmICghY2hpbGQgJiYgIShUR1QgaW4gZWwpKVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsIFRHVCwgeyB2YWx1ZTogZWwgfSk7XG4gICAgZWxzZSBpZiAoY2hpbGQgJiYgIShUR1QgaW4gY2hpbGQpKVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hpbGQsIFRHVCwgeyB2YWx1ZTogZWwgfSk7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hhdCBraW5kIG9mIGNoYW5nZSB0b29rIHBsYWNlIG9uIHRoZSBnaXZlbiBlbGVtZW50IGFuZCB0aGVuXG4gKiBwZXJmb3JtcyB0aGUgcHJvcGVyIGFuaW1hdGlvbiBiYXNlZCBvbiB0aGF0LlxuICogQHBhcmFtIGVsIC0gVGhlIHNwZWNpZmljIGVsZW1lbnQgdG8gYW5pbWF0ZS5cbiAqL1xuZnVuY3Rpb24gYW5pbWF0ZShlbCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgaXNNb3VudGVkID0gZWwuaXNDb25uZWN0ZWQ7XG4gICAgY29uc3QgcHJlRXhpc3RpbmcgPSBjb29yZHMuaGFzKGVsKTtcbiAgICBpZiAoaXNNb3VudGVkICYmIHNpYmxpbmdzLmhhcyhlbCkpXG4gICAgICAgIHNpYmxpbmdzLmRlbGV0ZShlbCk7XG4gICAgaWYgKCgoX2EgPSBhbmltYXRpb25zLmdldChlbCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wbGF5U3RhdGUpICE9PSBcImZpbmlzaGVkXCIpIHtcbiAgICAgICAgKF9iID0gYW5pbWF0aW9ucy5nZXQoZWwpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FuY2VsKCk7XG4gICAgfVxuICAgIGlmIChORVcgaW4gZWwpIHtcbiAgICAgICAgYWRkKGVsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJlRXhpc3RpbmcgJiYgaXNNb3VudGVkKSB7XG4gICAgICAgIHJlbWFpbihlbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByZUV4aXN0aW5nICYmICFpc01vdW50ZWQpIHtcbiAgICAgICAgcmVtb3ZlKGVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFkZChlbCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZW1vdmVzIGFsbCBub24tZGlnaXRzIGZyb20gYSBzdHJpbmcgYW5kIGNhc3RzIHRvIGEgbnVtYmVyLlxuICogQHBhcmFtIHN0ciAtIEEgc3RyaW5nIGNvbnRhaW5pbmcgYSBwaXhlbCB2YWx1ZS5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHJhdyhzdHIpIHtcbiAgICByZXR1cm4gTnVtYmVyKHN0ci5yZXBsYWNlKC9bXjAtOS5cXC1dL2csIFwiXCIpKTtcbn1cbi8qKlxuICogR2V0IHRoZSBzY3JvbGwgb2Zmc2V0IG9mIGVsZW1lbnRzXG4gKiBAcGFyYW0gZWwgLSBFbGVtZW50XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRTY3JvbGxPZmZzZXQoZWwpIHtcbiAgICBsZXQgcCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgICAgaWYgKHAuc2Nyb2xsTGVmdCB8fCBwLnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogcC5zY3JvbGxMZWZ0LCB5OiBwLnNjcm9sbFRvcCB9O1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbn1cbi8qKlxuICogR2V0IHRoZSBjb29yZGluYXRlcyBvZiBlbGVtZW50cyBhZGp1c3RlZCBmb3Igc2Nyb2xsIHBvc2l0aW9uLlxuICogQHBhcmFtIGVsIC0gRWxlbWVudFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0Q29vcmRzKGVsKSB7XG4gICAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0U2Nyb2xsT2Zmc2V0KGVsKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHJlY3QudG9wICsgeSxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgeCxcbiAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgd2lkdGgvaGVpZ2h0IHRoYXQgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIHRyYW5zaXRpb25lZCBiZXR3ZWVuLlxuICogVGhpcyB0YWtlcyBpbnRvIGFjY291bnQgYm94LXNpemluZy5cbiAqIEBwYXJhbSBlbCAtIEVsZW1lbnQgYmVpbmcgYW5pbWF0ZWRcbiAqIEBwYXJhbSBvbGRDb29yZHMgLSBPbGQgc2V0IG9mIENvb3JkaW5hdGVzIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0gbmV3Q29vcmRzIC0gTmV3IHNldCBvZiBDb29yZGluYXRlcyBjb29yZGluYXRlc1xuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblNpemVzKGVsLCBvbGRDb29yZHMsIG5ld0Nvb3Jkcykge1xuICAgIGxldCB3aWR0aEZyb20gPSBvbGRDb29yZHMud2lkdGg7XG4gICAgbGV0IGhlaWdodEZyb20gPSBvbGRDb29yZHMuaGVpZ2h0O1xuICAgIGxldCB3aWR0aFRvID0gbmV3Q29vcmRzLndpZHRoO1xuICAgIGxldCBoZWlnaHRUbyA9IG5ld0Nvb3Jkcy5oZWlnaHQ7XG4gICAgY29uc3Qgc3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgY29uc3Qgc2l6aW5nID0gc3R5bGVzLmdldFByb3BlcnR5VmFsdWUoXCJib3gtc2l6aW5nXCIpO1xuICAgIGlmIChzaXppbmcgPT09IFwiY29udGVudC1ib3hcIikge1xuICAgICAgICBjb25zdCBwYWRkaW5nWSA9IHJhdyhzdHlsZXMucGFkZGluZ1RvcCkgK1xuICAgICAgICAgICAgcmF3KHN0eWxlcy5wYWRkaW5nQm90dG9tKSArXG4gICAgICAgICAgICByYXcoc3R5bGVzLmJvcmRlclRvcFdpZHRoKSArXG4gICAgICAgICAgICByYXcoc3R5bGVzLmJvcmRlckJvdHRvbVdpZHRoKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ1ggPSByYXcoc3R5bGVzLnBhZGRpbmdMZWZ0KSArXG4gICAgICAgICAgICByYXcoc3R5bGVzLnBhZGRpbmdSaWdodCkgK1xuICAgICAgICAgICAgcmF3KHN0eWxlcy5ib3JkZXJSaWdodFdpZHRoKSArXG4gICAgICAgICAgICByYXcoc3R5bGVzLmJvcmRlckxlZnRXaWR0aCk7XG4gICAgICAgIHdpZHRoRnJvbSAtPSBwYWRkaW5nWDtcbiAgICAgICAgd2lkdGhUbyAtPSBwYWRkaW5nWDtcbiAgICAgICAgaGVpZ2h0RnJvbSAtPSBwYWRkaW5nWTtcbiAgICAgICAgaGVpZ2h0VG8gLT0gcGFkZGluZ1k7XG4gICAgfVxuICAgIHJldHVybiBbd2lkdGhGcm9tLCB3aWR0aFRvLCBoZWlnaHRGcm9tLCBoZWlnaHRUb10ubWFwKE1hdGgucm91bmQpO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgYW5pbWF0aW9uIG9wdGlvbnMgZm9yIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0gZWwgLSBFbGVtZW50IHRvIHJldHJpZXZlIG9wdGlvbnMgZm9yLlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0T3B0aW9ucyhlbCkge1xuICAgIHJldHVybiBUR1QgaW4gZWwgJiYgb3B0aW9ucy5oYXMoZWxbVEdUXSlcbiAgICAgICAgPyBvcHRpb25zLmdldChlbFtUR1RdKVxuICAgICAgICA6IHsgZHVyYXRpb246IDI1MCwgZWFzaW5nOiBcImVhc2UtaW4tb3V0XCIgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgdGFyZ2V0IG9mIGEgZ2l2ZW4gYW5pbWF0aW9uIChnZW5lcmFsbHkgdGhlIHBhcmVudCkuXG4gKiBAcGFyYW0gZWwgLSBBbiBlbGVtZW50IHRvIGNoZWNrIGZvciBhIHRhcmdldFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0KGVsKSB7XG4gICAgaWYgKFRHVCBpbiBlbClcbiAgICAgICAgcmV0dXJuIGVsW1RHVF07XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGFuaW1hdGlvbnMgYXJlIGVuYWJsZWQgb3IgZGlzYWJsZWQgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cbiAqIEBwYXJhbSBlbCAtIEFueSBlbGVtZW50XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc0VuYWJsZWQoZWwpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZWwpO1xuICAgIHJldHVybiB0YXJnZXQgPyBlbmFibGVkLmhhcyh0YXJnZXQpIDogZmFsc2U7XG59XG4vKipcbiAqIEl0ZXJhdGUgb3ZlciB0aGUgY2hpbGRyZW4gb2YgYSBnaXZlbiBwYXJlbnQuXG4gKiBAcGFyYW0gcGFyZW50IC0gQSBwYXJlbnQgZWxlbWVudFxuICogQHBhcmFtIGNhbGxiYWNrIC0gQSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBmb3JFYWNoKHBhcmVudCwgLi4uY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhwYXJlbnQsIG9wdGlvbnMuaGFzKHBhcmVudCkpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbi5pdGVtKGkpO1xuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soY2hpbGQsIG9wdGlvbnMuaGFzKGNoaWxkKSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIHR1cGxlIHRvIHByb3ZpZGUgY29uc2lzdGVudCBpbnRlcmZhY2VcbiAqL1xuZnVuY3Rpb24gZ2V0UGx1Z2luVHVwbGUocGx1Z2luUmV0dXJuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2luUmV0dXJuKSlcbiAgICAgICAgcmV0dXJuIHBsdWdpblJldHVybjtcbiAgICByZXR1cm4gW3BsdWdpblJldHVybl07XG59XG4vKipcbiAqIERldGVybWluZSBpZiBjb25maWcgaXMgcGx1Z2luXG4gKi9cbmZ1bmN0aW9uIGlzUGx1Z2luKGNvbmZpZykge1xuICAgIHJldHVybiB0eXBlb2YgY29uZmlnID09PSBcImZ1bmN0aW9uXCI7XG59XG4vKipcbiAqIFRoZSBlbGVtZW50IGluIHF1ZXN0aW9uIGlzIHJlbWFpbmluZyBpbiB0aGUgRE9NLlxuICogQHBhcmFtIGVsIC0gRWxlbWVudCB0byBmbGlwXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiByZW1haW4oZWwpIHtcbiAgICBjb25zdCBvbGRDb29yZHMgPSBjb29yZHMuZ2V0KGVsKTtcbiAgICBjb25zdCBuZXdDb29yZHMgPSBnZXRDb29yZHMoZWwpO1xuICAgIGlmICghaXNFbmFibGVkKGVsKSlcbiAgICAgICAgcmV0dXJuIGNvb3Jkcy5zZXQoZWwsIG5ld0Nvb3Jkcyk7XG4gICAgaWYgKGlzT2Zmc2NyZWVuKGVsKSkge1xuICAgICAgICAvLyBXaGVuIGVsZW1lbnQgaXMgb2Zmc2NyZWVuLCBza2lwIEZMSVAgdG8gYXZvaWQgYnJva2VuIHRyYW5zZm9ybXNcbiAgICAgICAgY29vcmRzLnNldChlbCwgbmV3Q29vcmRzKTtcbiAgICAgICAgb2JzZXJ2ZVBvc2l0aW9uKGVsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYW5pbWF0aW9uO1xuICAgIGlmICghb2xkQ29vcmRzKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcGx1Z2luT3JPcHRpb25zID0gZ2V0T3B0aW9ucyhlbCk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW5Pck9wdGlvbnMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBsZXQgZGVsdGFMZWZ0ID0gb2xkQ29vcmRzLmxlZnQgLSBuZXdDb29yZHMubGVmdDtcbiAgICAgICAgbGV0IGRlbHRhVG9wID0gb2xkQ29vcmRzLnRvcCAtIG5ld0Nvb3Jkcy50b3A7XG4gICAgICAgIGNvbnN0IGRlbHRhUmlnaHQgPSBvbGRDb29yZHMubGVmdCArIG9sZENvb3Jkcy53aWR0aCAtIChuZXdDb29yZHMubGVmdCArIG5ld0Nvb3Jkcy53aWR0aCk7XG4gICAgICAgIGNvbnN0IGRlbHRhQm90dG9tID0gb2xkQ29vcmRzLnRvcCArIG9sZENvb3Jkcy5oZWlnaHQgLSAobmV3Q29vcmRzLnRvcCArIG5ld0Nvb3Jkcy5oZWlnaHQpO1xuICAgICAgICAvLyBlbGVtZW50IGlzIHByb2JhYmx5IGFuY2hvcmVkIGFuZCBkb2Vzbid0IG5lZWQgdG8gYmUgb2Zmc2V0XG4gICAgICAgIGlmIChkZWx0YUJvdHRvbSA9PSAwKVxuICAgICAgICAgICAgZGVsdGFUb3AgPSAwO1xuICAgICAgICBpZiAoZGVsdGFSaWdodCA9PSAwKVxuICAgICAgICAgICAgZGVsdGFMZWZ0ID0gMDtcbiAgICAgICAgY29uc3QgW3dpZHRoRnJvbSwgd2lkdGhUbywgaGVpZ2h0RnJvbSwgaGVpZ2h0VG9dID0gZ2V0VHJhbnNpdGlvblNpemVzKGVsLCBvbGRDb29yZHMsIG5ld0Nvb3Jkcyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0ge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7ZGVsdGFMZWZ0fXB4LCAke2RlbHRhVG9wfXB4KWAsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVuZCA9IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgwLCAwKWAsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh3aWR0aEZyb20gIT09IHdpZHRoVG8pIHtcbiAgICAgICAgICAgIHN0YXJ0LndpZHRoID0gYCR7d2lkdGhGcm9tfXB4YDtcbiAgICAgICAgICAgIGVuZC53aWR0aCA9IGAke3dpZHRoVG99cHhgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHRGcm9tICE9PSBoZWlnaHRUbykge1xuICAgICAgICAgICAgc3RhcnQuaGVpZ2h0ID0gYCR7aGVpZ2h0RnJvbX1weGA7XG4gICAgICAgICAgICBlbmQuaGVpZ2h0ID0gYCR7aGVpZ2h0VG99cHhgO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdGlvbiA9IGVsLmFuaW1hdGUoW3N0YXJ0LCBlbmRdLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogcGx1Z2luT3JPcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nOiBwbHVnaW5Pck9wdGlvbnMuZWFzaW5nLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IFtrZXlmcmFtZXNdID0gZ2V0UGx1Z2luVHVwbGUocGx1Z2luT3JPcHRpb25zKGVsLCBcInJlbWFpblwiLCBvbGRDb29yZHMsIG5ld0Nvb3JkcykpO1xuICAgICAgICBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKGtleWZyYW1lcyk7XG4gICAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG4gICAgfVxuICAgIGFuaW1hdGlvbnMuc2V0KGVsLCBhbmltYXRpb24pO1xuICAgIGNvb3Jkcy5zZXQoZWwsIG5ld0Nvb3Jkcyk7XG4gICAgYW5pbWF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJmaW5pc2hcIiwgdXBkYXRlUG9zLmJpbmQobnVsbCwgZWwsIGZhbHNlKSwge1xuICAgICAgICBvbmNlOiB0cnVlLFxuICAgIH0pO1xufVxuLyoqXG4gKiBBZGRzIHRoZSBlbGVtZW50IHdpdGggYSB0cmFuc2l0aW9uLlxuICogQHBhcmFtIGVsIC0gQW5pbWF0ZXMgdGhlIGVsZW1lbnQgYmVpbmcgYWRkZWQuXG4gKi9cbmZ1bmN0aW9uIGFkZChlbCkge1xuICAgIGlmIChORVcgaW4gZWwpXG4gICAgICAgIGRlbGV0ZSBlbFtORVddO1xuICAgIGNvbnN0IG5ld0Nvb3JkcyA9IGdldENvb3JkcyhlbCk7XG4gICAgY29vcmRzLnNldChlbCwgbmV3Q29vcmRzKTtcbiAgICBjb25zdCBwbHVnaW5Pck9wdGlvbnMgPSBnZXRPcHRpb25zKGVsKTtcbiAgICBpZiAoIWlzRW5hYmxlZChlbCkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoaXNPZmZzY3JlZW4oZWwpKSB7XG4gICAgICAgIC8vIFNraXAgZW50cnkgYW5pbWF0aW9uIGlmIGVsZW1lbnQgaXMgbm90IHZpc2libGUgaW4gdmlld3BvcnRcbiAgICAgICAgb2JzZXJ2ZVBvc2l0aW9uKGVsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYW5pbWF0aW9uO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luT3JPcHRpb25zICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYW5pbWF0aW9uID0gZWwuYW5pbWF0ZShbXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogXCJzY2FsZSguOTgpXCIsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiBcInNjYWxlKDAuOTgpXCIsIG9wYWNpdHk6IDAsIG9mZnNldDogMC41IH0sXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogXCJzY2FsZSgxKVwiLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgIF0sIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBwbHVnaW5Pck9wdGlvbnMuZHVyYXRpb24gKiAxLjUsXG4gICAgICAgICAgICBlYXNpbmc6IFwiZWFzZS1pblwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IFtrZXlmcmFtZXNdID0gZ2V0UGx1Z2luVHVwbGUocGx1Z2luT3JPcHRpb25zKGVsLCBcImFkZFwiLCBuZXdDb29yZHMpKTtcbiAgICAgICAgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihrZXlmcmFtZXMpO1xuICAgICAgICBhbmltYXRpb24ucGxheSgpO1xuICAgIH1cbiAgICBhbmltYXRpb25zLnNldChlbCwgYW5pbWF0aW9uKTtcbiAgICBhbmltYXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImZpbmlzaFwiLCB1cGRhdGVQb3MuYmluZChudWxsLCBlbCwgZmFsc2UpLCB7XG4gICAgICAgIG9uY2U6IHRydWUsXG4gICAgfSk7XG59XG4vKipcbiAqIENsZWFuIHVwIGFmdGVyIHJlbW92aW5nIGFuIGVsZW1lbnQgZnJvbSB0aGUgZG9tLlxuICogQHBhcmFtIGVsIC0gRWxlbWVudCBiZWluZyByZW1vdmVkXG4gKiBAcGFyYW0gc3R5bGVzIC0gT3B0aW9uYWwgc3R5bGVzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gY2xlYW5VcChlbCwgc3R5bGVzKSB7XG4gICAgdmFyIF9hO1xuICAgIGVsLnJlbW92ZSgpO1xuICAgIGNvb3Jkcy5kZWxldGUoZWwpO1xuICAgIHNpYmxpbmdzLmRlbGV0ZShlbCk7XG4gICAgYW5pbWF0aW9ucy5kZWxldGUoZWwpO1xuICAgIChfYSA9IGludGVyc2VjdGlvbnMuZ2V0KGVsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKERFTCBpbiBlbClcbiAgICAgICAgICAgIGRlbGV0ZSBlbFtERUxdO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsIE5FVywgeyB2YWx1ZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICBpZiAoc3R5bGVzICYmIGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3R5bGUgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGVbc3R5bGVdID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIDApO1xufVxuLyoqXG4gKiBBbmltYXRlcyB0aGUgcmVtb3ZhbCBvZiBhbiBlbGVtZW50LlxuICogQHBhcmFtIGVsIC0gRWxlbWVudCB0byByZW1vdmVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghc2libGluZ3MuaGFzKGVsKSB8fCAhY29vcmRzLmhhcyhlbCkpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBbcHJldiwgbmV4dF0gPSBzaWJsaW5ncy5nZXQoZWwpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgREVMLCB7IHZhbHVlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgY29uc3QgZmluYWxYID0gd2luZG93LnNjcm9sbFg7XG4gICAgY29uc3QgZmluYWxZID0gd2luZG93LnNjcm9sbFk7XG4gICAgaWYgKG5leHQgJiZcbiAgICAgICAgbmV4dC5wYXJlbnROb2RlICYmXG4gICAgICAgIG5leHQucGFyZW50Tm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgbmV4dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbmV4dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByZXYgJiYgcHJldi5wYXJlbnROb2RlKSB7XG4gICAgICAgIHByZXYucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoX2EgPSBnZXRUYXJnZXQoZWwpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICBpZiAoIWlzRW5hYmxlZChlbCkpXG4gICAgICAgIHJldHVybiBjbGVhblVwKGVsKTtcbiAgICBjb25zdCBbdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0XSA9IGRlbGV0ZVBvc2l0aW9uKGVsKTtcbiAgICBjb25zdCBvcHRpb25zT3JQbHVnaW4gPSBnZXRPcHRpb25zKGVsKTtcbiAgICBjb25zdCBvbGRDb29yZHMgPSBjb29yZHMuZ2V0KGVsKTtcbiAgICBpZiAoZmluYWxYICE9PSBzY3JvbGxYIHx8IGZpbmFsWSAhPT0gc2Nyb2xsWSkge1xuICAgICAgICBhZGp1c3RTY3JvbGwoZWwsIGZpbmFsWCwgZmluYWxZLCBvcHRpb25zT3JQbHVnaW4pO1xuICAgIH1cbiAgICBsZXQgYW5pbWF0aW9uO1xuICAgIGxldCBzdHlsZVJlc2V0ID0ge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICB0b3A6IGAke3RvcH1weGAsXG4gICAgICAgIGxlZnQ6IGAke2xlZnR9cHhgLFxuICAgICAgICB3aWR0aDogYCR7d2lkdGh9cHhgLFxuICAgICAgICBoZWlnaHQ6IGAke2hlaWdodH1weGAsXG4gICAgICAgIG1hcmdpbjogXCIwXCIsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFwiY2VudGVyXCIsXG4gICAgICAgIHpJbmRleDogXCIxMDBcIixcbiAgICB9O1xuICAgIGlmICghaXNQbHVnaW4ob3B0aW9uc09yUGx1Z2luKSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGVsLnN0eWxlLCBzdHlsZVJlc2V0KTtcbiAgICAgICAgYW5pbWF0aW9uID0gZWwuYW5pbWF0ZShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDEpXCIsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKC45OClcIixcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSwge1xuICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnNPclBsdWdpbi5kdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogXCJlYXNlLW91dFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IFtrZXlmcmFtZXMsIG9wdGlvbnNdID0gZ2V0UGx1Z2luVHVwbGUob3B0aW9uc09yUGx1Z2luKGVsLCBcInJlbW92ZVwiLCBvbGRDb29yZHMpKTtcbiAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3R5bGVSZXNldCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHlsZVJlc2V0ID1cbiAgICAgICAgICAgICAgICAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnN0eWxlUmVzZXQpIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlUmVzZXQ7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGVsLnN0eWxlLCBzdHlsZVJlc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKGtleWZyYW1lcyk7XG4gICAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG4gICAgfVxuICAgIGFuaW1hdGlvbnMuc2V0KGVsLCBhbmltYXRpb24pO1xuICAgIGFuaW1hdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiZmluaXNoXCIsICgpID0+IGNsZWFuVXAoZWwsIHN0eWxlUmVzZXQpLCB7XG4gICAgICAgIG9uY2U6IHRydWUsXG4gICAgfSk7XG59XG4vKipcbiAqIElmIHRoZSBlbGVtZW50IGJlaW5nIHJlbW92ZWQgaXMgYXQgdGhlIHZlcnkgYm90dG9tIG9mIHRoZSBwYWdlLCBhbmQgdGhlXG4gKiB0aGUgcGFnZSB3YXMgc2Nyb2xsZWQgaW50byBhIHNwYWNlIGJlaW5nIFwibWFkZSBhdmFpbGFibGVcIiBieSB0aGUgZWxlbWVudFxuICogdGhhdCB3YXMgcmVtb3ZlZCwgdGhlIHBhZ2Ugc2Nyb2xsIHdpbGwgaGF2ZSBqdW1wZWQgdXAgc29tZSBhbW91bnQuIFdlIG5lZWRcbiAqIHRvIG9mZnNldCB0aGUganVtcCBieSB0aGUgYW1vdW50IHRoYXQgdGhlIHBhZ2Ugd2FzIFwiYXV0b21hdGljYWxseVwiIHNjcm9sbGVkXG4gKiB1cC4gV2UgY2FuIGRvIHRoaXMgYnkgY29tcGFyaW5nIHRoZSBzY3JvbGwgcG9zaXRpb24gYmVmb3JlIGFuZCBhZnRlciB0aGVcbiAqIGVsZW1lbnQgd2FzIHJlbW92ZWQsIGFuZCB0aGVuIG9mZnNldHRpbmcgYnkgdGhhdCBhbW91bnQuXG4gKlxuICogQHBhcmFtIGVsIC0gVGhlIGVsZW1lbnQgYmVpbmcgZGVsZXRlZFxuICogQHBhcmFtIGZpbmFsWCAtIFRoZSBmaW5hbCBYIHNjcm9sbCBwb3NpdGlvblxuICogQHBhcmFtIGZpbmFsWSAtIFRoZSBmaW5hbCBZIHNjcm9sbCBwb3NpdGlvblxuICogQHBhcmFtIG9wdGlvbnNPclBsdWdpbiAtIFRoZSBvcHRpb25zIG9yIHBsdWdpblxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gYWRqdXN0U2Nyb2xsKGVsLCBmaW5hbFgsIGZpbmFsWSwgb3B0aW9uc09yUGx1Z2luKSB7XG4gICAgY29uc3Qgc2Nyb2xsRGVsdGFYID0gc2Nyb2xsWCAtIGZpbmFsWDtcbiAgICBjb25zdCBzY3JvbGxEZWx0YVkgPSBzY3JvbGxZIC0gZmluYWxZO1xuICAgIGNvbnN0IHNjcm9sbEJlZm9yZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvcjtcbiAgICBjb25zdCBzY3JvbGxCZWhhdmlvciA9IGdldENvbXB1dGVkU3R5bGUocm9vdCkuc2Nyb2xsQmVoYXZpb3I7XG4gICAgaWYgKHNjcm9sbEJlaGF2aW9yID09PSBcInNtb290aFwiKSB7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IFwiYXV0b1wiO1xuICAgIH1cbiAgICB3aW5kb3cuc2Nyb2xsVG8od2luZG93LnNjcm9sbFggKyBzY3JvbGxEZWx0YVgsIHdpbmRvdy5zY3JvbGxZICsgc2Nyb2xsRGVsdGFZKTtcbiAgICBpZiAoIWVsLnBhcmVudEVsZW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBwYXJlbnQgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIGxldCBsYXN0SGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodDtcbiAgICBsZXQgbGFzdFdpZHRoID0gcGFyZW50LmNsaWVudFdpZHRoO1xuICAgIGNvbnN0IHN0YXJ0U2Nyb2xsID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgLy8gSGVyZSB3ZSB1c2UgYSBtYW51YWwgc2Nyb2xsIGFuaW1hdGlvbiB0byBrZWVwIHRoZSBlbGVtZW50IHVzaW5nIHRoZSBzYW1lXG4gICAgLy8gZWFzaW5nIGFuZCB0aW1pbmcgYXMgdGhlIHBhcmVudOKAmXMgc2Nyb2xsIGFuaW1hdGlvbi5cbiAgICBmdW5jdGlvbiBzbW9vdGhTY3JvbGwoKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzUGx1Z2luKG9wdGlvbnNPclBsdWdpbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVkgPSBsYXN0SGVpZ2h0IC0gcGFyZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVggPSBsYXN0V2lkdGggLSBwYXJlbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0U2Nyb2xsICsgb3B0aW9uc09yUGx1Z2luLmR1cmF0aW9uID5cbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2Uubm93KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHdpbmRvdy5zY3JvbGxYIC0gZGVsdGFYLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB3aW5kb3cuc2Nyb2xsWSAtIGRlbHRhWSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RIZWlnaHQgPSBwYXJlbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBsYXN0V2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gc2Nyb2xsQmVmb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNtb290aFNjcm9sbCgpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCBiZWluZyByZW1vdmVkLlxuICogQHBhcmFtIGVsIC0gVGhlIGVsZW1lbnQgYmVpbmcgZGVsZXRlZFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZGVsZXRlUG9zaXRpb24oZWwpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgb2xkQ29vcmRzID0gY29vcmRzLmdldChlbCk7XG4gICAgY29uc3QgW3dpZHRoLCAsIGhlaWdodF0gPSBnZXRUcmFuc2l0aW9uU2l6ZXMoZWwsIG9sZENvb3JkcywgZ2V0Q29vcmRzKGVsKSk7XG4gICAgbGV0IG9mZnNldFBhcmVudCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJlxuICAgICAgICAoZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiIHx8XG4gICAgICAgICAgICBvZmZzZXRQYXJlbnQgaW5zdGFuY2VvZiBIVE1MQm9keUVsZW1lbnQpKSB7XG4gICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICBpZiAoIW9mZnNldFBhcmVudClcbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gZG9jdW1lbnQuYm9keTtcbiAgICBjb25zdCBwYXJlbnRTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCk7XG4gICAgY29uc3QgcGFyZW50Q29vcmRzID0gIWFuaW1hdGlvbnMuaGFzKGVsKSB8fCAoKF9hID0gYW5pbWF0aW9ucy5nZXQoZWwpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGxheVN0YXRlKSA9PT0gXCJmaW5pc2hlZFwiXG4gICAgICAgID8gZ2V0Q29vcmRzKG9mZnNldFBhcmVudClcbiAgICAgICAgOiBjb29yZHMuZ2V0KG9mZnNldFBhcmVudCk7XG4gICAgY29uc3QgdG9wID0gTWF0aC5yb3VuZChvbGRDb29yZHMudG9wIC0gcGFyZW50Q29vcmRzLnRvcCkgLVxuICAgICAgICByYXcocGFyZW50U3R5bGVzLmJvcmRlclRvcFdpZHRoKTtcbiAgICBjb25zdCBsZWZ0ID0gTWF0aC5yb3VuZChvbGRDb29yZHMubGVmdCAtIHBhcmVudENvb3Jkcy5sZWZ0KSAtXG4gICAgICAgIHJhdyhwYXJlbnRTdHlsZXMuYm9yZGVyTGVmdFdpZHRoKTtcbiAgICByZXR1cm4gW3RvcCwgbGVmdCwgd2lkdGgsIGhlaWdodF07XG59XG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBhdXRvbWF0aWNhbGx5IGFkZHMgYW5pbWF0aW9uIGVmZmVjdHMgdG8gaXRzZWxmIGFuZCBpdHNcbiAqIGltbWVkaWF0ZSBjaGlsZHJlbi4gU3BlY2lmaWNhbGx5IGl0IGFkZHMgZWZmZWN0cyBmb3IgYWRkaW5nLCBtb3ZpbmcsIGFuZFxuICogcmVtb3ZpbmcgRE9NIGVsZW1lbnRzLlxuICogQHBhcmFtIGVsIC0gQSBwYXJlbnQgZWxlbWVudCB0byBhZGQgYW5pbWF0aW9ucyB0by5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IG9mIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGF1dG9BbmltYXRlKGVsLCBjb25maWcgPSB7fSkge1xuICAgIGlmIChzdXBwb3J0ZWRCcm93c2VyICYmIHJlc2l6ZSkge1xuICAgICAgICBjb25zdCBtZWRpYVF1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKVwiKTtcbiAgICAgICAgY29uc3QgaXNEaXNhYmxlZER1ZVRvUmVkdWNlTW90aW9uID0gbWVkaWFRdWVyeS5tYXRjaGVzICYmXG4gICAgICAgICAgICAhaXNQbHVnaW4oY29uZmlnKSAmJlxuICAgICAgICAgICAgIWNvbmZpZy5kaXNyZXNwZWN0VXNlck1vdGlvblByZWZlcmVuY2U7XG4gICAgICAgIGlmICghaXNEaXNhYmxlZER1ZVRvUmVkdWNlTW90aW9uKSB7XG4gICAgICAgICAgICBlbmFibGVkLmFkZChlbCk7XG4gICAgICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShlbCkucG9zaXRpb24gPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGVsLnN0eWxlLCB7IHBvc2l0aW9uOiBcInJlbGF0aXZlXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3JFYWNoKGVsLCB1cGRhdGVQb3MsIHBvbGwsIChlbGVtZW50KSA9PiByZXNpemUgPT09IG51bGwgfHwgcmVzaXplID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNpemUub2JzZXJ2ZShlbGVtZW50KSk7XG4gICAgICAgICAgICBpZiAoaXNQbHVnaW4oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2V0KGVsLCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zZXQoZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDI1MCxcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBcImVhc2UtaW4tb3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoaGFuZGxlTXV0YXRpb25zKTtcbiAgICAgICAgICAgIG1vLm9ic2VydmUoZWwsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgICAgICAgbXV0YXRpb25PYnNlcnZlcnMuc2V0KGVsLCBtbyk7XG4gICAgICAgICAgICBwYXJlbnRzLmFkZChlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBwYXJlbnQ6IGVsLFxuICAgICAgICBlbmFibGU6ICgpID0+IHtcbiAgICAgICAgICAgIGVuYWJsZWQuYWRkKGVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzYWJsZTogKCkgPT4ge1xuICAgICAgICAgICAgZW5hYmxlZC5kZWxldGUoZWwpO1xuICAgICAgICAgICAgLy8gQ2FuY2VsIGFueSBpbi1mbGlnaHQgYW5pbWF0aW9ucyBhbmQgcGVuZGluZyB0aW1lcnMgZm9yIGltbWVkaWF0ZSBlZmZlY3RcbiAgICAgICAgICAgIGZvckVhY2goZWwsIChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGFuaW1hdGlvbnMuZ2V0KG5vZGUpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPT09IG51bGwgfHwgYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggeyB9XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9ucy5kZWxldGUobm9kZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IGRlYm91bmNlcy5nZXQobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGQpXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChkKTtcbiAgICAgICAgICAgICAgICBkZWJvdW5jZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBpbnRlcnZhbHMuZ2V0KG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGkpO1xuICAgICAgICAgICAgICAgIGludGVydmFscy5kZWxldGUobm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNFbmFibGVkOiAoKSA9PiBlbmFibGVkLmhhcyhlbCksXG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICAgIGVuYWJsZWQuZGVsZXRlKGVsKTtcbiAgICAgICAgICAgIHBhcmVudHMuZGVsZXRlKGVsKTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVsZXRlKGVsKTtcbiAgICAgICAgICAgIGNvbnN0IG1vID0gbXV0YXRpb25PYnNlcnZlcnMuZ2V0KGVsKTtcbiAgICAgICAgICAgIG1vID09PSBudWxsIHx8IG1vID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtby5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBtdXRhdGlvbk9ic2VydmVycy5kZWxldGUoZWwpO1xuICAgICAgICAgICAgZm9yRWFjaChlbCwgKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB1bm9ic2VydmUgcmVzaXplXG4gICAgICAgICAgICAgICAgcmVzaXplID09PSBudWxsIHx8IHJlc2l6ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzaXplLnVub2JzZXJ2ZShub2RlKTtcbiAgICAgICAgICAgICAgICAvLyBjYW5jZWwgYW5pbWF0aW9uc1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBhbmltYXRpb25zLmdldChub2RlKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhID09PSBudWxsIHx8IGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGEuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIHsgfVxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnMuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIGRpc2Nvbm5lY3Qgb2JzZXJ2ZXJzXG4gICAgICAgICAgICAgICAgY29uc3QgaW8gPSBpbnRlcnNlY3Rpb25zLmdldChub2RlKTtcbiAgICAgICAgICAgICAgICBpbyA9PT0gbnVsbCB8fCBpbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW8uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbnMuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIGNsZWFyIGludGVydmFscyBhbmQgZGVib3VuY2VzXG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IGludGVydmFscy5nZXQobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaSk7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxzLmRlbGV0ZShub2RlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gZGVib3VuY2VzLmdldChub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoZClcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGQpO1xuICAgICAgICAgICAgICAgIGRlYm91bmNlcy5kZWxldGUobm9kZSk7XG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgc3RhdGVcbiAgICAgICAgICAgICAgICBjb29yZHMuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgICAgIHNpYmxpbmdzLmRlbGV0ZShub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBjb250cm9sbGVyO1xufVxuLyoqXG4gKiBUaGUgdnVlIGRpcmVjdGl2ZS5cbiAqL1xuY29uc3QgdkF1dG9BbmltYXRlID0ge1xuICAgIG1vdW50ZWQ6IChlbCwgYmluZGluZykgPT4ge1xuICAgICAgICBjb25zdCBjdGwgPSBhdXRvQW5pbWF0ZShlbCwgYmluZGluZy52YWx1ZSB8fCB7fSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgXCJfX2FhX2N0bFwiLCB7IHZhbHVlOiBjdGwsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICB9LFxuICAgIHVubW91bnRlZDogKGVsKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY3RsID0gZWxbXCJfX2FhX2N0bFwiXTtcbiAgICAgICAgKF9hID0gY3RsID09PSBudWxsIHx8IGN0bCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3RsLmRlc3Ryb3kpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGN0bCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWxldGUgZWxbXCJfX2FhX2N0bFwiXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7IH1cbiAgICB9LFxuICAgIGdldFNTUlByb3BzOiAoKSA9PiAoe30pLFxufTtcblxuZXhwb3J0IHsgYXV0b0FuaW1hdGUsIGF1dG9BbmltYXRlIGFzIGRlZmF1bHQsIGdldFRyYW5zaXRpb25TaXplcywgdkF1dG9BbmltYXRlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@formkit+auto-animate@0.9.0/node_modules/@formkit/auto-animate/index.mjs\n");

/***/ })

};
;