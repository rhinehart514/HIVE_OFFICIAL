(()=>{var a={};a.id=8811,a.ids=[8811],a.modules={261:a=>{"use strict";a.exports=require("next/dist/shared/lib/router/utils/app-paths")},3295:a=>{"use strict";a.exports=require("next/dist/server/app-render/after-task-async-storage.external.js")},4573:a=>{"use strict";a.exports=require("node:buffer")},10846:a=>{"use strict";a.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},11767:()=>{},14276:a=>{"use strict";a.exports=import("firebase-admin/auth")},16495:()=>{},19121:a=>{"use strict";a.exports=require("next/dist/server/app-render/action-async-storage.external.js")},29294:a=>{"use strict";a.exports=require("next/dist/server/app-render/work-async-storage.external.js")},32547:(a,b,c)=>{"use strict";c.r(b),c.d(b,{handler:()=>Y,patchFetch:()=>X,routeModule:()=>T,serverHooks:()=>W,workAsyncStorage:()=>U,workUnitAsyncStorage:()=>V});var d={};c.r(d),c.d(d,{DELETE:()=>E,GET:()=>C,POST:()=>B,PUT:()=>D});var e=c(98128),f=c(48869),g=c(78868),h=c(37526),i=c(21884),j=c(261),k=c(24218),l=c(73640),m=c(66376),n=c(36363),o=c(73605),p=c(76583),q=c(19465),r=c(78910),s=c(86439),t=c(48724),u=c(73641),v=c(38929),w=c(93272),x=c(97338),y=c(87266),z=c(25384);async function A(a){try{let b=a.cookies.get("hive_session");if(b?.value){let a=await (0,w.gV)(b.value);if(a?.userId&&a?.email)return{uid:a.userId,email:a.email}}let c=a.headers.get("Authorization");if(c?.startsWith("Bearer ")){let a=c.replace("Bearer ",""),b=await v.authAdmin.verifyIdToken(a);return{uid:b.uid,email:b.email}}return null}catch(a){return x.v.error("Auth verification failed",{error:a instanceof Error?a.message:String(a)}),null}}async function B(a){try{let b=await A(a);if(!b)return u.NextResponse.json(y.cR.error("Unauthorized","UNAUTHORIZED"),{status:y.t3.UNAUTHORIZED});let{toolId:c,deploymentId:d,spaceId:e,updateType:f,eventData:g,targetUsers:h=[],broadcastToSpace:i=!0,requiresAck:j=!1,expiresInMinutes:k=60}=await a.json();if(!c||!f||!g)return u.NextResponse.json(y.cR.error("Tool ID, update type, and event data are required","INVALID_INPUT"),{status:y.t3.BAD_REQUEST});if(!await F(b.uid,c,d,e))return u.NextResponse.json(y.cR.error("Not authorized to update this tool","FORBIDDEN"),{status:y.t3.FORBIDDEN});let l=await v.dbAdmin.collection("tools").doc(c).get();if(!l.exists)return u.NextResponse.json(y.cR.error("Tool not found","RESOURCE_NOT_FOUND"),{status:y.t3.NOT_FOUND});let m=l.data();if(!m)return u.NextResponse.json(y.cR.error("Tool data not found","RESOURCE_NOT_FOUND"),{status:y.t3.NOT_FOUND});let n=h;0===n.length&&(n=await H(c,d,e));let o=await K(c,d),p=await J(c,d),q={id:`tool_update_${c}_${Date.now()}_${Math.random().toString(36).substr(2,8)}`,toolId:c,toolName:m?.name||"Unknown Tool",deploymentId:d,spaceId:e,userId:b.uid,updateType:f,eventData:{...g,changedFields:g.changedFields||[],metadata:{...g.metadata,triggeredBy:b.uid,timestamp:new Date().toISOString()}},affectedUsers:n,timestamp:new Date().toISOString(),sequenceNumber:p,broadcastChannels:function(a,b,c,d=!0){let e=[];return e.push(`tool:${a}:updates`),b&&e.push(`deployment:${b}:updates`),c&&d&&e.push(`space:${c}:tools`),e}(c,d,e,i),requiresAck:j,expiresAt:k?new Date(Date.now()+60*k*1e3).toISOString():void 0};return await v.dbAdmin.collection("toolUpdateEvents").doc(q.id).set(q),await L(q,o),await N(q),await O(q,n),j&&await P(q),u.NextResponse.json({success:!0,updateEvent:{id:q.id,toolId:c,updateType:f,sequenceNumber:p,affectedUsers:n.length,timestamp:q.timestamp}})}catch(a){return x.v.error("Error processing tool update at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)}),u.NextResponse.json(y.cR.error("Failed to process tool update","INTERNAL_ERROR"),{status:y.t3.INTERNAL_SERVER_ERROR})}}async function C(a){try{let b=await A(a);if(!b)return u.NextResponse.json(y.cR.error("Unauthorized","UNAUTHORIZED"),{status:y.t3.UNAUTHORIZED});let{searchParams:c}=new URL(a.url),d=c.get("deploymentId"),e=c.get("spaceId");if((a.headers.get("Accept")||"").includes("text/event-stream")&&d)return function(a,b,c){let d=new TextEncoder,e=!0,f=null;return new Response(new ReadableStream({start(c){let g=`data: ${JSON.stringify({type:"connected",deploymentId:b,timestamp:new Date().toISOString()})}

`;c.enqueue(d.encode(g));let h=setInterval(()=>{if(!e)return void clearInterval(h);try{let a=`data: ${JSON.stringify({type:"heartbeat",timestamp:new Date().toISOString()})}

`;c.enqueue(d.encode(a))}catch{clearInterval(h)}},3e4),i=`${b}_${a}`;v.dbAdmin.collection("toolStates").doc(i);let j=v.dbAdmin.collection("toolStates").doc(b),k=setInterval(async()=>{if(!e)return void clearInterval(k);try{for(let e of(await v.dbAdmin.collection("toolUpdateEvents").where("deploymentId","==",b).where("timestamp",">",new Date(Date.now()-5e3).toISOString()).orderBy("timestamp","desc").limit(5).get()).docs){let b=e.data();if(b.userId===a)continue;let f=`data: ${JSON.stringify({type:"state_update",state:b.eventData?.newState||{},updateType:b.updateType,timestamp:b.timestamp,triggeredBy:b.userId})}

`;c.enqueue(d.encode(f))}let e=await j.get();if(e.exists){let b=e.data(),f=b?.updatedAt,g=new Date(Date.now()-5e3).toISOString();if(f&&f>g&&b?.userId!==a){let a=`data: ${JSON.stringify({type:"state_update",state:b?.state||{},timestamp:f})}

`;c.enqueue(d.encode(a))}}}catch(a){x.v.error("SSE poll error",{error:a instanceof Error?a.message:String(a)})}},2e3);f=()=>{e=!1,clearInterval(h),clearInterval(k)}},cancel(){e=!1,f&&f()}}),{headers:{"Content-Type":"text/event-stream","Cache-Control":"no-cache, no-transform",Connection:"keep-alive","X-Accel-Buffering":"no"}})}(b.uid,d,0);let f=c.get("toolId"),g=c.get("since"),h=parseInt(c.get("limit")||"50"),i="true"===c.get("includeSnapshot");if(!f)return u.NextResponse.json(y.cR.error("Tool ID is required","INVALID_INPUT"),{status:y.t3.BAD_REQUEST});if(!await G(b.uid,f,d??void 0,e??void 0))return u.NextResponse.json(y.cR.error("Access denied to this tool","FORBIDDEN"),{status:y.t3.FORBIDDEN});let j=v.dbAdmin.collection("toolUpdateEvents").where("toolId","==",f);d&&(j=j.where("deploymentId","==",d)),e&&(j=j.where("spaceId","==",e)),g&&(j=j.where("timestamp",">",g)),j=j.orderBy("sequenceNumber","desc").limit(h);let k=await j.get(),l=k.docs.map(a=>({id:a.id,...a.data()})),m=null;i&&(m=await K(f,d??void 0));let n=await Q(f,d??void 0,b.uid);return u.NextResponse.json({success:!0,updates:l.reverse(),stateSnapshot:m,syncStatus:n,hasMore:k.docs.length===h,lastSequenceNumber:l.length>0?Math.max(...l.map(a=>a.sequenceNumber)):0})}catch(a){return x.v.error("Error getting tool updates at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)}),u.NextResponse.json(y.cR.error("Failed to get tool updates","INTERNAL_ERROR"),{status:y.t3.INTERNAL_SERVER_ERROR})}}async function D(a){try{let b=await A(a);if(!b)return u.NextResponse.json(y.cR.error("Unauthorized","UNAUTHORIZED"),{status:y.t3.UNAUTHORIZED});let{toolId:c,deploymentId:d,clientVersion:e,clientState:f,conflictResolution:g="latest_wins",forceMerge:h=!1}=await a.json();if(!c||void 0===e||!f)return u.NextResponse.json(y.cR.error("Tool ID, client version, and client state are required","INVALID_INPUT"),{status:y.t3.BAD_REQUEST});if(!await G(b.uid,c,d??void 0))return u.NextResponse.json(y.cR.error("Access denied to this tool","FORBIDDEN"),{status:y.t3.FORBIDDEN});let i=await K(c,d);if(!i)return await M(c,d,f,b.uid),u.NextResponse.json({success:!0,syncResult:"client_state_accepted",serverState:f,serverVersion:1,conflicts:[]});if(i.version===e&&!h){let a={id:`sync_${c}_${Date.now()}`,toolId:c,toolName:"Tool",deploymentId:d,spaceId:void 0,userId:b.uid,updateType:"state_change",eventData:{previousState:i.currentState,newState:f,changedFields:R(i.currentState,f),metadata:{syncedFrom:"client"}},affectedUsers:[],timestamp:new Date().toISOString(),sequenceNumber:0,broadcastChannels:[],requiresAck:!1};return await L(a,i),u.NextResponse.json({success:!0,syncResult:"sync_successful",serverState:f,serverVersion:i.version+1,conflicts:[]})}let j=await S(c,d,i,f,e,g,b.uid);return u.NextResponse.json({success:!0,syncResult:"conflict_resolved",serverState:j.resolvedState,serverVersion:j.newVersion,conflicts:j.conflicts,resolutionStrategy:g})}catch(a){return x.v.error("Error syncing tool state at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)}),u.NextResponse.json(y.cR.error("Failed to sync tool state","INTERNAL_ERROR"),{status:y.t3.INTERNAL_SERVER_ERROR})}}async function E(a){try{let b=await A(a);if(!b)return u.NextResponse.json(y.cR.error("Unauthorized","UNAUTHORIZED"),{status:y.t3.UNAUTHORIZED});let{searchParams:c}=new URL(a.url),d=c.get("toolId"),e=c.get("deploymentId"),f=c.get("olderThan"),g=c.get("eventId");if(!d)return u.NextResponse.json(y.cR.error("Tool ID is required","INVALID_INPUT"),{status:y.t3.BAD_REQUEST});if(!await F(b.uid,d,e??void 0))return u.NextResponse.json(y.cR.error("Not authorized to clean up this tool","FORBIDDEN"),{status:y.t3.FORBIDDEN});let h=0;if(g){let a=await v.dbAdmin.collection("toolUpdateEvents").doc(g).get();a.exists&&a.data()?.toolId===d&&(await v.dbAdmin.collection("toolUpdateEvents").doc(g).delete(),h=1)}else{if(!f)return u.NextResponse.json(y.cR.error("Event ID or olderThan parameter required","INVALID_INPUT"),{status:y.t3.BAD_REQUEST});let a=new Date(f).toISOString(),b=v.dbAdmin.collection("toolUpdateEvents").where("toolId","==",d).where("timestamp","<",a);e&&(b=b.where("deploymentId","==",e));let c=await b.get(),g=c.docs.map(a=>a.ref.delete());await Promise.all(g),h=c.size}return u.NextResponse.json({success:!0,deletedCount:h,message:`Cleaned up ${h} tool update events`})}catch(a){return x.v.error("Error cleaning up tool updates at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)}),u.NextResponse.json(y.cR.error("Failed to clean up tool updates","INTERNAL_ERROR"),{status:y.t3.INTERNAL_SERVER_ERROR})}}async function F(a,b,c,d){try{let e=await v.dbAdmin.collection("tools").doc(b).get();if(!e.exists)return!1;let f=e.data();if(f?.authorId===a)return!0;if(c){let b=await v.dbAdmin.collection("toolDeployments").doc(c).get();if(b.exists){let c=b.data();if(c?.deployedBy===a)return!0}}if(d){let b=v.dbAdmin.collection("spaceMembers").where("userId","==",a).where("spaceId","==",d).where("status","==","active").where("campusId","==",z.e3),c=await b.get();if(!c.empty){let a=c.docs[0].data();return["builder","moderator","admin"].includes(a.role||"member")}}return!1}catch(a){return x.v.error("Error verifying tool update permission at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)}),!1}}async function G(a,b,c,d){try{let e=await v.dbAdmin.collection("tools").doc(b).get();if(e.exists&&e.data()?.authorId===a)return!0;if(c){let b=await v.dbAdmin.collection("toolDeployments").doc(c).get();if(b.exists){let c=b.data();if(c?.deployedBy===a)return!0;if(c?.spaceId){let b=v.dbAdmin.collection("spaceMembers").where("userId","==",a).where("spaceId","==",c.spaceId).where("status","==","active").where("campusId","==",z.e3);return!(await b.get()).empty}}}if(d){let b=v.dbAdmin.collection("spaceMembers").where("userId","==",a).where("spaceId","==",d).where("status","==","active").where("campusId","==",z.e3);return!(await b.get()).empty}return!1}catch(a){return x.v.error("Error verifying tool access at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)}),!1}}async function H(a,b,c){try{let d=new Set,e=await v.dbAdmin.collection("tools").doc(a).get();if(e.exists){let a=e.data();a?.authorId&&d.add(a.authorId)}if(b){let a=await v.dbAdmin.collection("toolDeployments").doc(b).get();if(a.exists){let b=a.data();b?.deployedBy&&d.add(b.deployedBy),b?.spaceId&&(await I(b.spaceId)).forEach(a=>d.add(a))}}return c&&(await I(c)).forEach(a=>d.add(a)),Array.from(d)}catch(a){return x.v.error("Error getting tool users at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)}),[]}}async function I(a){try{let b=v.dbAdmin.collection("spaceMembers").where("spaceId","==",a).where("status","==","active").where("campusId","==",z.e3);return(await b.get()).docs.map(a=>a.data().userId)}catch(a){return x.v.error("Error getting space members at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)}),[]}}async function J(a,b){try{let c=b?`${a}_${b}`:a,d=await v.dbAdmin.collection("toolStateSnapshots").doc(c).get();if(d.exists)return d.data().version+1;return 1}catch(a){return x.v.error("Error getting next sequence number at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)}),Date.now()}}async function K(a,b){try{let c=b?`${a}_${b}`:a,d=await v.dbAdmin.collection("toolStateSnapshots").doc(c).get();if(d.exists)return{...d.data()};return null}catch(a){return x.v.error("Error getting tool state snapshot at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)}),null}}async function L(a,b){try{let c,d=a.deploymentId?`${a.toolId}_${a.deploymentId}`:a.toolId;c=b?{...b,currentState:a.eventData.newState||b.currentState,lastUpdate:a.timestamp,version:a.sequenceNumber,metadata:{...b.metadata,updatedBy:a.userId,syncStatus:"synced"}}:{toolId:a.toolId,deploymentId:a.deploymentId,spaceId:a.spaceId,currentState:a.eventData.newState||{},lastUpdate:a.timestamp,version:a.sequenceNumber,activeConnections:[],pendingUpdates:[],metadata:{createdAt:a.timestamp,updatedBy:a.userId,syncStatus:"synced"}},await v.dbAdmin.collection("toolStateSnapshots").doc(d).set(c)}catch(a){x.v.error("Error updating tool state snapshot at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)})}}async function M(a,b,c,d){try{let e=b?`${a}_${b}`:a,f={toolId:a,deploymentId:b,currentState:c,lastUpdate:new Date().toISOString(),version:1,activeConnections:[],pendingUpdates:[],metadata:{createdAt:new Date().toISOString(),updatedBy:d,syncStatus:"synced"}};await v.dbAdmin.collection("toolStateSnapshots").doc(e).set(f)}catch(a){x.v.error("Error creating tool state snapshot at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)})}}async function N(a){try{for(let b of a.broadcastChannels){let c={id:`tool_update_broadcast_${a.id}_${Date.now()}`,type:"tool_update",channel:b,senderId:"system",content:{action:"tool_updated",updateEvent:{id:a.id,toolId:a.toolId,toolName:a.toolName,updateType:a.updateType,timestamp:a.timestamp,sequenceNumber:a.sequenceNumber,eventData:a.eventData}},metadata:{timestamp:new Date().toISOString(),priority:"normal",requiresAck:a.requiresAck,expiresAt:a.expiresAt,retryCount:0},delivery:{sent:[],delivered:[],read:[],failed:[]}};await v.dbAdmin.collection("realtimeMessages").add(c)}}catch(a){x.v.error("Error broadcasting tool update at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)})}}async function O(a,b){try{for(let c of b)a.toolName,a.toolName,a.updateType,a.toolId,a.spaceId,a.toolId,a.deploymentId&&a.deploymentId,a.updateType}catch(a){x.v.error("Error notifying affected users at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)})}}async function P(a){try{let b={updateEventId:a.id,toolId:a.toolId,requiredAcks:a.affectedUsers,receivedAcks:[],ackDeadline:a.expiresAt||new Date(Date.now()+36e5).toISOString(),createdAt:new Date().toISOString(),status:"pending"};await v.dbAdmin.collection("toolUpdateAcks").doc(a.id).set(b)}catch(a){x.v.error("Error initializing ack tracking at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)})}}async function Q(a,b,c){try{let c=await K(a,b);if(!c)return{status:"no_state",lastSync:null,version:0,pendingUpdates:0};return{status:c.metadata.syncStatus,lastSync:c.lastUpdate,version:c.version,pendingUpdates:c.pendingUpdates.length,activeConnections:c.activeConnections.length}}catch(a){return x.v.error("Error getting tool sync status at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)}),{status:"error",lastSync:null,version:0,pendingUpdates:0}}}function R(a,b){let c=[];for(let d of new Set([...Object.keys(a||{}),...Object.keys(b||{})]))JSON.stringify(a?.[d])!==JSON.stringify(b?.[d])&&c.push(d);return c}async function S(a,b,c,d,e,f,g){try{let h;switch(f){case"latest_wins":default:h=c.currentState;break;case"client_wins":h=d;break;case"merge":h={...c.currentState||{},...d||{}}}let i={id:`conflict_resolution_${a}_${Date.now()}`,toolId:a,toolName:"Tool",deploymentId:b,spaceId:void 0,userId:g,updateType:"configuration_change",eventData:{previousState:c.currentState,newState:h,changedFields:R(c.currentState,h),metadata:{conflictResolution:f,clientVersion:e,serverVersion:c.version}},affectedUsers:[],timestamp:new Date().toISOString(),sequenceNumber:0,broadcastChannels:[],requiresAck:!1};return await L(i,c),{resolvedState:h,newVersion:c.version+1,conflicts:[],strategy:f}}catch(a){throw x.v.error("Error resolving tool state conflict at /api/realtime/tool-updates",{error:a instanceof Error?a.message:String(a)}),a}}let T=new e.AppRouteRouteModule({definition:{kind:f.RouteKind.APP_ROUTE,page:"/api/realtime/tool-updates/route",pathname:"/api/realtime/tool-updates",filename:"route",bundlePath:"app/api/realtime/tool-updates/route"},distDir:".next",relativeProjectDir:"",resolvedPagePath:"/Users/laneyfraass/Desktop/HIVE/apps/web/src/app/api/realtime/tool-updates/route.ts",nextConfigOutput:"",userland:d}),{workAsyncStorage:U,workUnitAsyncStorage:V,serverHooks:W}=T;function X(){return(0,g.patchFetch)({workAsyncStorage:U,workUnitAsyncStorage:V})}async function Y(a,b,c){var d;let e="/api/realtime/tool-updates/route";"/index"===e&&(e="/");let g=await T.prepare(a,b,{srcPage:e,multiZoneDraftMode:!1});if(!g)return b.statusCode=400,b.end("Bad Request"),null==c.waitUntil||c.waitUntil.call(c,Promise.resolve()),null;let{buildId:u,params:v,nextConfig:w,isDraftMode:x,prerenderManifest:y,routerServerContext:z,isOnDemandRevalidate:A,revalidateOnlyGenerated:B,resolvedPathname:C}=g,D=(0,j.normalizeAppPath)(e),E=!!(y.dynamicRoutes[D]||y.routes[C]);if(E&&!x){let a=!!y.routes[C],b=y.dynamicRoutes[D];if(b&&!1===b.fallback&&!a)throw new s.NoFallbackError}let F=null;!E||T.isDev||x||(F="/index"===(F=C)?"/":F);let G=!0===T.isDev||!E,H=E&&!G,I=a.method||"GET",J=(0,i.getTracer)(),K=J.getActiveScopeSpan(),L={params:v,prerenderManifest:y,renderOpts:{experimental:{cacheComponents:!!w.experimental.cacheComponents,authInterrupts:!!w.experimental.authInterrupts},supportsDynamicResponse:G,incrementalCache:(0,h.getRequestMeta)(a,"incrementalCache"),cacheLifeProfiles:null==(d=w.experimental)?void 0:d.cacheLife,isRevalidate:H,waitUntil:c.waitUntil,onClose:a=>{b.on("close",a)},onAfterTaskError:void 0,onInstrumentationRequestError:(b,c,d)=>T.onRequestError(a,b,d,z)},sharedContext:{buildId:u}},M=new k.NodeNextRequest(a),N=new k.NodeNextResponse(b),O=l.NextRequestAdapter.fromNodeNextRequest(M,(0,l.signalFromNodeResponse)(b));try{let d=async c=>T.handle(O,L).finally(()=>{if(!c)return;c.setAttributes({"http.status_code":b.statusCode,"next.rsc":!1});let d=J.getRootSpanAttributes();if(!d)return;if(d.get("next.span_type")!==m.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${d.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let e=d.get("next.route");if(e){let a=`${I} ${e}`;c.setAttributes({"next.route":e,"http.route":e,"next.span_name":a}),c.updateName(a)}else c.updateName(`${I} ${a.url}`)}),g=async g=>{var i,j;let k=async({previousCacheEntry:f})=>{try{if(!(0,h.getRequestMeta)(a,"minimalMode")&&A&&B&&!f)return b.statusCode=404,b.setHeader("x-nextjs-cache","REVALIDATED"),b.end("This page could not be found"),null;let e=await d(g);a.fetchMetrics=L.renderOpts.fetchMetrics;let i=L.renderOpts.pendingWaitUntil;i&&c.waitUntil&&(c.waitUntil(i),i=void 0);let j=L.renderOpts.collectedTags;if(!E)return await (0,o.I)(M,N,e,L.renderOpts.pendingWaitUntil),null;{let a=await e.blob(),b=(0,p.toNodeOutgoingHttpHeaders)(e.headers);j&&(b[r.NEXT_CACHE_TAGS_HEADER]=j),!b["content-type"]&&a.type&&(b["content-type"]=a.type);let c=void 0!==L.renderOpts.collectedRevalidate&&!(L.renderOpts.collectedRevalidate>=r.INFINITE_CACHE)&&L.renderOpts.collectedRevalidate,d=void 0===L.renderOpts.collectedExpire||L.renderOpts.collectedExpire>=r.INFINITE_CACHE?void 0:L.renderOpts.collectedExpire;return{value:{kind:t.CachedRouteKind.APP_ROUTE,status:e.status,body:Buffer.from(await a.arrayBuffer()),headers:b},cacheControl:{revalidate:c,expire:d}}}}catch(b){throw(null==f?void 0:f.isStale)&&await T.onRequestError(a,b,{routerKind:"App Router",routePath:e,routeType:"route",revalidateReason:(0,n.c)({isRevalidate:H,isOnDemandRevalidate:A})},z),b}},l=await T.handleResponse({req:a,nextConfig:w,cacheKey:F,routeKind:f.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:y,isRoutePPREnabled:!1,isOnDemandRevalidate:A,revalidateOnlyGenerated:B,responseGenerator:k,waitUntil:c.waitUntil});if(!E)return null;if((null==l||null==(i=l.value)?void 0:i.kind)!==t.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==l||null==(j=l.value)?void 0:j.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});(0,h.getRequestMeta)(a,"minimalMode")||b.setHeader("x-nextjs-cache",A?"REVALIDATED":l.isMiss?"MISS":l.isStale?"STALE":"HIT"),x&&b.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let m=(0,p.fromNodeOutgoingHttpHeaders)(l.value.headers);return(0,h.getRequestMeta)(a,"minimalMode")&&E||m.delete(r.NEXT_CACHE_TAGS_HEADER),!l.cacheControl||b.getHeader("Cache-Control")||m.get("Cache-Control")||m.set("Cache-Control",(0,q.getCacheControlHeader)(l.cacheControl)),await (0,o.I)(M,N,new Response(l.value.body,{headers:m,status:l.value.status||200})),null};K?await g(K):await J.withPropagatedContext(a.headers,()=>J.trace(m.BaseServerSpan.handleRequest,{spanName:`${I} ${a.url}`,kind:i.SpanKind.SERVER,attributes:{"http.method":I,"http.target":a.url}},g))}catch(b){if(b instanceof s.NoFallbackError||await T.onRequestError(a,b,{routerKind:"App Router",routePath:D,routeType:"route",revalidateReason:(0,n.c)({isRevalidate:H,isOnDemandRevalidate:A})}),E)throw b;return await (0,o.I)(M,N,new Response(null,{status:500})),null}}},44870:a=>{"use strict";a.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},46675:a=>{"use strict";a.exports=require("firebase-admin")},55511:a=>{"use strict";a.exports=require("crypto")},57975:a=>{"use strict";a.exports=require("node:util")},63033:a=>{"use strict";a.exports=require("next/dist/server/app-render/work-unit-async-storage.external.js")},77598:a=>{"use strict";a.exports=require("node:crypto")},86439:a=>{"use strict";a.exports=require("next/dist/shared/lib/no-fallback-error.external")},87266:(a,b,c)=>{"use strict";c.d(b,{cR:()=>d,t3:()=>e});class d{static success(a,b,c){return{success:!0,...void 0!==a&&{data:a},...b&&{message:b},meta:{timestamp:new Date().toISOString(),...c}}}static error(a,b,c,d){return{success:!1,error:a,..."string"==typeof b?{code:b}:{},...void 0!==c?{details:c}:{},meta:{timestamp:new Date().toISOString(),...d?{endpoint:d}:{}}}}static validationError(a,b){return{success:!1,error:"Validation failed",code:"VALIDATION_ERROR",details:a,meta:{timestamp:new Date().toISOString(),...b?{endpoint:b}:{}}}}static paginated(a,b,c){return{success:!0,data:a,...c?{message:c}:{},meta:{timestamp:new Date().toISOString(),pagination:b,total:b.total}}}}let e={OK:200,CREATED:201,ACCEPTED:202,NO_CONTENT:204,BAD_REQUEST:400,UNAUTHORIZED:401,FORBIDDEN:403,NOT_FOUND:404,METHOD_NOT_ALLOWED:405,CONFLICT:409,UNPROCESSABLE_ENTITY:422,TOO_MANY_REQUESTS:429,INTERNAL_SERVER_ERROR:500,NOT_IMPLEMENTED:501,SERVICE_UNAVAILABLE:503}},91714:(a,b,c)=>{"use strict";c.d(b,{H4:()=>f,Ng:()=>g,h4:()=>d.h,q7:()=>e,vF:()=>d.v});var d=c(97338);function e(a,b){return{info:(c,e)=>d.v.info(c,{...e,requestId:a,userId:b}),warn:(c,e)=>d.v.warn(c,{...e,requestId:a,userId:b}),error:(c,e)=>d.v.error(c,{...e,requestId:a,userId:b}),debug:(c,e)=>d.v.debug(c,{...e,requestId:a,userId:b})}}async function f(a,b,c){d.v.info(`API ${a} ${b}`,{method:a,path:b,...c})}async function g(a,b){d.v.info(`Performance: ${a}`,{operation:a,...b})}}};var b=require("../../../../webpack-runtime.js");b.C(a);var c=b.X(0,[7545,1684,5524,2845,3272,5384],()=>b(b.s=32547));module.exports=c})();