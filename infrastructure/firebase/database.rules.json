{
  "rules": {
    ".read": "auth != null",
    ".write": "auth != null",
    
    "users": {
      "$uid": {
        // Users can read/write only their own data
        ".read": "auth != null && auth.uid == $uid",
        ".write": "auth != null && auth.uid == $uid",
        
        "profile": {
          ".read": "auth != null", // All authenticated users can read profiles
          ".write": "auth != null && auth.uid == $uid" // Only the owner can write
        },
        
        "private": {
          ".read": "auth != null && auth.uid == $uid", // Only the owner can read private data
          ".write": "auth != null && auth.uid == $uid" // Only the owner can write
        }
      }
    },
    
    "messages": {
      ".read": "auth != null",
      ".write": "auth != null",
      
      "$messageId": {
        // Only sender or recipient can read/write the message
        ".read": "auth != null && (data.child('senderId').val() == auth.uid || data.child('recipientId').val() == auth.uid)",
        ".write": "auth != null && (data.child('senderId').val() == auth.uid || newData.child('senderId').val() == auth.uid)"
      }
    },
    
    "chats": {
      "$chatId": {
        // Validate that only participants can access the chat
        ".read": "auth != null && (data.child('participants').child(auth.uid).exists())",
        ".write": "auth != null && (data.child('participants').child(auth.uid).exists() || !data.exists())"
      }
    },
    
    "events": {
      ".read": "auth != null", // All authenticated users can read events
      
      "$eventId": {
        // Only creator can modify the event
        ".write": "auth != null && (!data.exists() || data.child('createdBy').val() == auth.uid)"
      }
    },
    
    "userActivity": {
      "$uid": {
        // Users can only read/write their own activity
        ".read": "auth != null && auth.uid == $uid",
        ".write": "auth != null && auth.uid == $uid"
      }
    },
    
    "notifications": {
      "$uid": {
        // Users can only read/write their own notifications
        ".read": "auth != null && auth.uid == $uid",
        ".write": "auth != null && (auth.uid == $uid || root.child('admins').child(auth.uid).exists())"
      }
    },
    
    "admins": {
      // Only admins can read/write admin data
      ".read": "auth != null && root.child('admins').child(auth.uid).exists()",
      ".write": "auth != null && root.child('admins').child(auth.uid).exists()"
    },
    
    "feedContent": {
      // All authenticated users can read feed content
      ".read": "auth != null",
      // Only admins can write to feed content
      ".write": "auth != null && root.child('admins').child(auth.uid).exists()"
    },

    "setupDeployments": {
      // HiveLab Setups - Real-time orchestration data
      // Structure:
      // setupDeployments/{deploymentId}/
      //   ├── tools/{slotId}/visible (boolean)
      //   ├── sharedData/{key} (counters, dynamic values)
      //   └── orchestration/currentPhase (string)

      "$deploymentId": {
        // All authenticated users can read deployment data
        // (Firestore rules handle space membership, RTDB for real-time updates)
        ".read": "auth != null",

        "tools": {
          "$slotId": {
            "visible": {
              // Authenticated users can read visibility state
              ".read": "auth != null",
              // Only server (admin SDK) can update visibility via orchestration
              ".write": false
            },

            ".read": "auth != null",
            ".write": false
          }
        },

        "sharedData": {
          // Shared counters and data for cross-tool communication
          "$dataKey": {
            ".read": "auth != null",
            // Space members can update shared data (RSVP counts, check-in counts, etc.)
            // Firestore is source of truth; RTDB for real-time broadcasting
            ".write": "auth != null",
            // Validate counter operations
            ".validate": "newData.isNumber() || newData.isString() || newData.isBoolean() || newData.hasChildren()"
          }
        },

        "orchestration": {
          // Orchestration state is read-only for clients
          // Server updates via admin SDK based on rule execution
          ".read": "auth != null",
          ".write": false,

          "currentPhase": {
            ".read": "auth != null",
            ".write": false
          },

          "activeRules": {
            ".read": "auth != null",
            ".write": false
          },

          "lastTriggeredAt": {
            ".read": "auth != null",
            ".write": false
          }
        }
      }
    },

    "tool_state": {
      // Real-time tool state broadcasting (polls, RSVPs, leaderboards)
      // Server (Admin SDK) writes after each tool action execution
      // Clients subscribe for instant updates across all users
      "$deploymentId": {
        ".read": "auth != null",
        // Only server (admin SDK) can write tool state
        // Client reads only — Firestore is source of truth
        ".write": false,

        "counters": {
          ".read": "auth != null"
        },

        "collections": {
          ".read": "auth != null"
        },

        "timeline": {
          ".read": "auth != null"
        },

        "metadata": {
          ".read": "auth != null"
        }
      }
    },

    "spacePresence": {
      // Real-time presence for spaces (typing indicators, online members)
      "$spaceId": {
        ".read": "auth != null",

        "typing": {
          "$userId": {
            ".read": "auth != null",
            ".write": "auth != null && auth.uid == $userId",
            // Auto-expire typing indicators after 5 seconds
            ".validate": "newData.hasChildren(['timestamp', 'boardId']) && newData.child('timestamp').val() > now - 10000"
          }
        },

        "online": {
          "$userId": {
            ".read": "auth != null",
            ".write": "auth != null && auth.uid == $userId"
          }
        }
      }
    }
  }
}